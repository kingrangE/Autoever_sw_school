# 12월 22 수업 복습

## OOP

### 클래스란?
- 자주 쓰는 `Block들을 묶어서 관리`하는 것
    - `Block`이란?
        - `C언어`와 같은 `구조적 프로그래밍 언어`에서 코드를 구분하는 방식 (`{}`)
        - 클래스를 사용하는 `객체 지향 프로그래밍 언어`에서도 `Block을 사용하여 구분`한다.
    - 이전에는 이 `Block`들을 `File로 묶어서 관리`했음
        - ex, C언어 `Header 파일`
    - 현재는 `Class 단위로 관리`하는 방식 -> `객체 지향 프로그래밍`
        - 이 Class들을 또 다시 성격이 비슷한 Class끼리 묶은 것 -> `Library`, `Package`
    - 이전 배포 방식
        - DB 따로, Application 따로 묶어서 관리
            - ex, DB = {DB1,DB2 ...}, APP = {APP1,APP2...}
    - 현재 배포 방식
        - 같은 성격의 Application을 묶어서 관리 (`Kubernetes`)
            - ex, A = {DB1,APP1}, B = {DB2,APP2}
### OOP 특징
1. Encapsulation (캡슐화)
    - 내부 데이터(필드)를 `외부에서 보지 못하도록(수정하지 못하도록) 숨기고`, `허용된 메서드(Getter/Setter)를 통해서만 접근`할 수 있게 하는 것 -> `객체의 독립성`을 높임
2. Inheritance (상속)
    - `상위 클래스`의 `모든 요소`를 `하위 클래스가 물려받는 것`
        - `상속의 주체` == `하위 클래스`
            - Why?
                - 상속의 목적 중 하나 -> `중복 제거`
                - `두 개 이상의 클래스에서 발생한 중복을 상위 클래스를 생성하여 빼는 것`이기 때문에 `상속의 주체`는 `하위 클래스`
        - 따라서 UML(소프트웨어 시스템의 구조, 동작, 상호작용을 시각적으로 모델링하고 설계하기 위한 표준화된 그래픽 표기법)에서는 `상위 클래스 <- 하위 클래스로 표기`해야 한다.
            - 오버라이딩의 경우 `상위 -> 하위`
                - 오버라이딩은 중복한 것을 빼는게 아니라 상위의 것을 하위에서 바꾸는거니까
    - 목적
        1. 중복 제거 : 개발자가 중복되는 코드를 뿌려놓으면 수정 시에 빠뜨릴 위험이 있고, 이는 곧 에러로 연결됨. 이를 해결하는 것이 상속
        2. 효율성 제고 : 내가 개발에서 자주 사용하는 기능을 빼서 만들면 편리함
            - ex, 패키지, 라이브러리 등
3. Polymophism (다형성)
    - 동일한 코드가 호출하는 대상에 따라 다른 작업을 수행하는 것
        - 파이썬은 `Duck Typing`이라는 개념을 통해 `강한 다형성`을 제공한다.
            - 타입에 얽매이지 않고, 같은 이름의 메서드를 호출할 수 있는 기능
    - 다형성의 핵심
        1. Overriding : 상속받은 `클래스`를 자식 클래스에서 `재정의 하는 것`
        2. Overloading : `같은 이름의 메서드`를 `매개변수만 다르게 하여 여러 개 만드는 것`
            - 파이썬은 오버로딩을 지원하지 않지만, *args,**kwargs같은 가변 매개변수로 구현 가능
    - 예시
        - 마우스 좌클릭 하나로 여러 기능을 구현, 더블클릭, 드래그 등
4. Abstact (추상화)
    - Template을 만드는 것
    - 자식 클래스가 상속받아 구현하도록 함.
    - Abstact Class의 변형 -> Interface

## 클래스
### 클래스 구성
1. `Attribute(Property)` : 데이터
2. `Method` : 작업
### Class와 Instance
- `Class` : `자료형` -> 기본적으로 불변
- `Instance` : `Class 자료형을 기반`으로 `Memory를 할당받은 데이터` - `동적(변경 가능)`
- 파이썬에서 `Instance`생성 방법
    ```python
    class Test():
        pass
    a = Test()  # 클래스이름([데이터])
    ```
- `Class`나 `Instance`를 이용해서 `자신의 구성요소(Attr,Method)를 호출`할 때 -> `.` 이용
- `Method 호출` (In Python)
    - `Class 내부`에서 `호출` -> `이름`만으로 호출
    - `Class 외부`에서 `호출` -> 2가지 방식
        1. `클래스이름.메서드이름(인스턴스이름[,데이터])` 
            - `Unbound` 호출
            - `클래스만 호출`할 수 있는 코드
        2. `인스턴스이름.메서드이름([데이터])` 
            - `Bound` 호출
            - `Instance만 호출`할 수 있는 코드

### Instance Method 생성
- 클래스 안에 생성한다.
    ```python
    def 메서드이름(인스턴스를 위한 이름[, 데이터]): 
        내용
    ```
    - 인스턴스를 위한 이름 == `인스턴스 객체를 받아주는 파라미터`
        - 관례 상 `self`를 사용한다.
- Instance
    - Class를 `참조하는 주소와 속성`을 가진다.
    - 즉, Instance로 `메서드에 접근`하여 `작업을 진행`하는 경우라고 가정하자.
        - Instance는 메서드를 가지지 않는다. 즉, `자신이 참조하는 클래스로 이동`하여 `작업을 진행`해야 한다.
            - 그런데 Class는 Instance가 가진 속성에 대한 정보가 없다.
                - 즉, Class로 접근해서 메서드를 실행하는 경우에는 Instance에 대한 참조를 같이 전달해서, 인스턴스의 정보를 출력하도록 해야 한다.
- `Instance`의 `속성`
    - Method안에서 `self.속성이름`을 사용하면, `self 인스턴스가 소유하는 속성을 호출`하는 것
    - `처음 호출하면 생성`된다.
        - 기존에는 Class에 저장된 변수 영역으로 가서 값을 참조함.
        - 만약 Instance로 특정 속성의 값을 설정했다면, instance에 변수를 생성하여 값을 관리함.
### Attribute (Property)
- 클래스 내부에 선언한 데이터
- 종류
    1. `Class내`에서 생성
        - 여기서 생성한 데이터는 `Class`와 `Instance` 모두 접근 가능하다.
        - 이 데이터를 누가 수정하냐에 따라 다르다.
            1. `Class`가 수정 -> `전체 클래스 데이터 수정`
                ```python
                class Test:
                    a = 1
                Test.a = 2
                test = Test()
                print(test.a) #2
                ```
                - Class는 `메모리의 Static 영역에 저장`이 된다.
                    - 해당 영역에 `Class`, `Class 변수`, `인스턴스 메서드 코드 등이 저장`된다.
                        - 이때, `Class 변수`는 `클래스 객체 내부의 __dict__에 값이 저장`되고, `모든 인스턴스`는 `우선 이 주소값을 참조`한다.
                        - `모든 인스턴스가 이 주소값을 참조`하기 때문에, `Class 내에서 생성된 Attribute를 Class로 수정`하면 해당 클래스를 참조하는 `모든 인스턴스의 값이 변경`된다.
            2. `Instance`에서 수정 -> `인스턴스 하나의 데이터 수정`
                ```python
                class Test:
                    a = 1
                test = Test()
                test.a = 2
                print(Test.a) #1
                print(test.a) #2
                ```
                - 위에서 설명했듯, 모든 인스턴스는 생성 당시에 Attribute를 갖지 않고, `클래스를 참조`하기만 한다.
                    - 이때, `인스턴스로 접근(.)`하여 `Attribute를 수정, 설정`하는 경우
                        - 해당 인스턴스에 내장된 딕셔너리(`__dict__`)에 `값을 추가(저장)`한다.
    2. `Instance`에서 생성
        - Instance에서 생성도 1-2와 같은 로직이다.
        - 새로운 attribute를 Instance에서 생성하면 Instance의 딕셔너리에 값이 추가(저장)된다.
            - 이 값은 오직 해당 Instance만 참조하기 때문에, 클래스나 다른 인스턴스가 접근하지 못한다.
                - 따라서, 혼자 쓰는 것이라고 봐도 무방

### == 과 is
- `==` : 값이 동일한지 비교
- `is` : id가 동일한지 비교

### getter / setter : 접근자 메서드
- 모든 객체 지향 언어에서는 `속성에 직접 접근`하는 것을 권장하지 않는다.
    - 위에서 한 것처럼 .으로 바로 접근하는 것을 말한다. (JAVA에서는 이를 방지하기 위해 변수를 private 처리한다.)
    - 따라서, 속성은 `메서드를 이용`하여 `접근`하는 것을 권장한다.
    - 이때, 속성을 읽을 때 사용하는 것이 `getter`, 속성을 설정(수정)할 때 사용하는 것이 `setter`다.
#### getter 생성법
- 이름 : get_속성명 (ex, `get_name`)
- 매개변수 : 없음
- 내용 : 속성값을 리턴 
- 단, 속성의 자료형이 `bool`인 경우 `is`라고 이름을 표기하기도 한다.
- `속성의 자료형`이 `Container`인 경우, Index를 받아서 그 `Index에 해당하는 데이터`를 반환하도록 하기도 한다.

#### setter 생성법
- 이름 : set_속성명 (ex, `set_name`)
- 매개변수 : 수정할 데이터
- 내용 : 매개변수로 속성의 값 수정
- `속성의 자료형`이 `Container`인 경우, Index를 받아서 그 `Index에 해당하는 데이터`를 수정하도록 하기도 한다.

### 특수 속성
- `__`로 시작해서 `__`로 끝나는 속성
    - 특별한 목적으로 사용할 수 있도록 Python이 제공한다.
    - ex, `__name__`, `__doc__` 등

### 생성자와 소멸자
#### 생성자
- `클래스를 기반으로 인스턴스를 생성`하면 아래의 두 작업을 진행한다.
    1. 메모리 할당
    2. 초기화 작업
- 파이썬에서는 `__init__`을 설정하면 `instance 생성 과정에서 진행할 작업을 실행`하도록 한다.

#### 소멸자
- Instance가 `메모리에서 소멸될 때 호출`되는 메서드
- 파이썬에서는 `__del__`을 설정하면, `instance 소멸 과정에서 진행할 작업을 실행`하도록 한다.
- 파이썬의 메모리 해제 방식
    1. 파이썬은 데이터를 메모리에 할당하면, 참조카운트를 1로 만든다.
        ```python
        class a :
            pass
        v1 = a() # a 인스턴스 참조 카운트 1
        ```
    2. 이 데이터를 참조하는 다른 데이터가 생성되면, 참조 카운트를 1 증가시킨다.
        ```python
        class a :
            pass
        v1 = a() # a 인스턴스 참조 카운트 1
        v2 = v1 # a 인스턴스 참조 카운트 2
        ```
    3. 이 데이터를 참조하는 데이터가 소멸되면, 참조 카운트를 1 감소시킨다.
    4. 참조 카운트가 0이 되면, 메모리에서 해제된다. 
        - 참조 카운트 (reference count)가 0이 되면, Garbage Collector가 제거한다.
    - 소멸자에 작성하는 내용
        - `외부 자원(파일, 다른 프로그램 등)`을 사용했을 때, `외부 자원과의 연결 해제 코드를 작성`

### Static Method
- 인스턴스를 생성하지 않고, `Class로 호출할 수 있는 메서드`
- `self`,`cls`없이 생성한다.
    - 즉, `self`로 접근하는 `인스턴스 속성`, `인스턴스 메서드`를 `호출할 수 없다.`
    - 즉, `cls`로 접근하는 `클래스 변수`에 접근할 수 없다.
- `인스턴스를 이용`해서 호출할 수는 있다. -> `권장하지 않음`
    - 코드의 명확성이 떨어짐. 이게 인스턴스 메서드인지 먼지 모름
- 생성 방식
    - `@staticmethod` 데코레이터를 `메서드 상단에 추가`해주면 된다.
        ```python
        class example:
            def test(self): #일반 인스턴스 메서드
                pass
            @staticmethod
            def static_test(): # static method
                pass
        example.static_test() # 클래스로 바로 사용 가능
        ```

### Class Method
- Instance를 생성하지 않고, `Class로 호출할 수 있는 메서드`
- self 대신에 `첫 번째 매개변수`로 `Class Instance`를 의미하는 `cls`를 작성한다.
    - self가 없으므로 `self`로 접근하는 `인스턴스 속성`, `인스턴스 메서드`를 `호출할 수 없다.`
- `Instance를 이용`하여 `Class Method를 호출하는 것은 가능`하다.
- `@classmethod` 데코레이터를 `메서드 상단에 추가`해주면 된다.
    ```python
    class example:
        def test(self): #일반 인스턴스 메서드
            pass
        @classmethod
        def class_test(cls): # class method
            pass
    example.class_test() 
    ```
- Static과 ClassMethod의 차이
    - Class 변수에 접근할 수 있는지의 차이가 존재한다.
    - 따라서 아래와 같은 상황에 유용하다.
        1. Factory Method
            - 상황에 따라 다르게 init해야 되는 경우
                - ex, 소셜 로그인 여러개 -> kakao,google 2개는 정보가 다르다. 그런 경우 아래와 같이 구현 가능
                    ```python
                    class User:
                        def __init__(self,id,pw,host):
                            self.id = id
                            self.pw = pw
                            self.host = host
                        @classmethod
                        def google_login(cls,id,pw):
                            cls(id,pw,"google") #구글로 전달
                        @classmethod
                        def kakao_login(cls,id,pw):
                            cls(id,pw,"kakao")
                    user1 = User.google_login(id,pw) #구글로 로그인하는 경우
                    user2 = User.kakao_login(id,pw) #카카오로 로그인하는 경우
                    ```
        2. 클래스 변수를 수정해야 하는 경우
            - 당연히 static method는 클래스 접근이 불가하므로 ClassMethod여야 한다.

### 동적 속성 추가 제한
- (C++,JAVA,C#)과 (Python, JS) 모두 `동적 프로그래밍 언어`
    - BUT, 후자 -> `Instance에 동적으로 속성을 추가할 수 있음`
        - 하지만, 이렇게 막 추가하면, 일관성이 없고 프로그램 예측이 힘들어진다.
        - 따라서 이러한 동적 추가를 막아야 좋다.
- 동적 속성 추가를 제한하려면 `__slot__` 이라는 속성에 `list형태로 속성 이름을 정의해두면` 된다.
    ```python
    class whatever:
        def __init__(self,a,b,c):
            self.a = a
            self.b = b
            self.c = c
    w = whatever(1,2,3)
    w.d = 4
    print(w.a,w.b,w.c,w.d) #1 2 3 4
    class restrict:
        __slots__=["a","b","c"]
        def __init__(self,a,b,c):
            self.a = a
            self.b = b
            self.c = c
    w = whatever(1,2,3)
    w.d = 4 # Error
    print(w.a,w.b,w.c,w.d) # Error
    ```
### 접근 지정자
- 데이터의 `접근`을 `제한`하거나 `허용`하도록 해주는 것
- 클래스 내부에서는 `모든 속성`과 `메서드`를 호출 가능
    - BUT, 클래스 외부(인스턴스)에서는 `접근을 제한`하는 것
- 파이썬은 `기본적으로 모두 Public`이다.
    - JAVA처럼 private, protected, public을 구분하여 설정할 수 있는 것이 아님.
    - public - `"아무데서나 접근 가능"`
    - private - `"클래스 자기 자신만 접근 가능"`
    - protected - private + `"자신을 상속하는 클래스"`
- 파이썬에서
    1. protected를 만들고 싶다. : `_`를 변수명 앞에 붙이자.
        ```python
        class A : 
            _a = 1 # protected 변수 a
        ```
    2. private를 만들고 싶다. : `__`를 변수명 앞에 붙이자.
        ```python
        class A:
            __a = 1 # private 변수 a
        ```
### Property
- `속성을 직접 호출하는 것처럼 사용`하지만, 실제로는 `접근자 메서드를 호출`하는 것으로 처리되는 `Attribute`
- 사용 이유
    1. 메서드를 사용하여 접근하는 것보다 간편함.
    2. 메서드의 장점인 예외 처리가 가능해짐. (아무 값이나 받는 것이 불가하도록 할 수 있음)
        - 기본적으로 속성 직접 접근은 파이썬의 특징 상 세상 모든 값을 넣을 수 있다.
        - 하지만, Property를 이용하면, 접근자 메서드에서 잘못된 값은 Error Raise로 대처할 수 있다.
    3. 로그 기록에 유용하다. 
        - 누가 접근해서 어떻게 했는지 알 수 있다. (접근자 메서드 처리가 포함되기 때문)
- 사용 방법
    1. property 클래스 사용
        - 속성 이름 = `property(fget=None,fset=None,fdel=None,doc=None)`
            - `fget` = getter 함수 등록
            - `fset` = setter 함수 등록
            - `fdel` = delete 함수 등록
            - `doc` = document 작성
        - 예시 
            ```python
            class test :
                def getId(self):
                    return self.__id
                def setId(self,id):
                    self.__id = id
                id = property(fget=getId,fset=setId)

            t = test()
            t.id = 1
            print(t.id)
            ```
    2. property 데코레이터 사용
        - getter 메서드 위에 `@property`, setter 메서드 위에 `property이름.setter`라고 설정하면 된다.
            - 여기서 `메서드 명`은 `둘 다 반환하는 속성 이름`으로 한다.
        - 예시
            ```python
            class A:
                @property
                def a(self):
                    return self.__a
                @a.setter
                def a(self,c):
                    self.__a = c
            ```

### Operator Overloading (연산자 오버로딩)
#### Overloading, Overriding
- Overloading : `동일한 클래스`에 `매개변수의 개수`나 `자료형`이 다른 동일한 메서드를 여러 개 만드는 것
    - 파이썬에서는 구현이 막혀있다. (메서드 이름이 같은 경우, 가장 `마지막에 정의된 메서드가 덮어 씌움`)
    - 대신 `가변 매개변수`,`Default Parameter` 등을 사용하여 여러 역할을 수행하게 할 수는 있다.
- Overriding : `상위 클래스의 메서드`를 `하위 클래스`에서 `다시 정의`하는 것
    - 목적 : 기능 확장 
        - `기능 확장`이 목적이므로, `상위 클래스의 메서드(기존 메서드)`를 실행을 포함하여 오버라이딩 해야 한다.
        - 만약, 그냥 새로운 기능을 하고싶은거면, 이름을 새로 지어야 한다.
#### 연산자 오버로딩
- 연산자의 기능을 추가하는 것이다.
    - `Instance`끼리 서로 연산을 할 수 있게끔 `기존에 있는 연산자의 기능을 변경하여 사용하는 것`이다.
- 방식 : 연산자에 해당하는 `특정 이름의 메서드`를 정의해주면 된다.
    - ex
        - `+` : `__add__`
        - `-` : `__sub__`
        - `__str__` : 스페셜 메서드
            - 해당 객체의 정보를 문자열로 반환하는 메서드
            - 이를 구현하지 않으면, 객체가 저장된 id가 출력된다.
- `아직 정의가 안 된` 경우 -> 기능 추가
- `이미 정의`가 된 경우 -> 기능 재정의

### Method Overriding (메소드 오버라이딩)
- `상위 클래스에서 만들어진 메서드`를 `하위 클래스에서 다시 정의`하는 것
    - 목적 : `기능 확장`
- Method Overriding 방식
    1. `상위 클래스의 메서드 호출` -> `추가할 기능 구현`
        ```python
        class Super:
            def greeting(self):
                print("상위 클래스")
        class Sub(Super):
            def greeting(self):
                super().greeting()
                print("Sub 추가 기능")
        ```
    2. `추가할 기능 구현` -> `상위 클래스 메서드 호출`

- 클래스 관계를 계란으로 생각해보기 
    - 노른자 -> 상위 클래스
    - 흰자 -> 하위 클래스
    - EX) 계란을 만든다. (클래스를 생성한다.)
        - 계란을 만들 때 노른자부터 만들어야 함.
        - 즉, 클래스도 `생성을 상위 클래스부터` 함
    - EX) 계란을 부순다. (클래스를 해제한다.)
        - 계란을 부술 때, 흰자부터 제거해야 함.
        - 즉, 클래스도 `해제를 하위 클래스부터` 함.

### 싱글톤 패턴
- `Class의 인스턴스`를 `딱 1개`만 만드는 `디자인 패턴`
- `서버 프로그래밍`에서 중요
    - WHY?
        - 서버는 `안정성`이 중요. 데이터 또한 안전하게, 신뢰도 있게 관리해야 함.
        - 만약 DB 인스턴스를 여러 개 생성할 수 있다면, 동시에 처리하려거나 순서가 어긋나서 에러가 날 수 있다.
        - 하지만 하나라면, 요청받은 순서대로 처리하니까 예상에서 빗나갈 일이 없다.
- 예시
    ```python
    class Singleton :
        __instance = None
        def __new__(cls,*args,**kwargs):
            if cls.__instance is None :
                # Class에 instance가 없는 경우, 새로 생성한다.
                cls.__instance = object.__new__(cls,*args,**kwargs) 
            return cls.__instance
    class Sub(Singleton):
        a = 10
    t1 = Sub()
    t2 = Sub()
    print(t1 is t2) # True -> 둘이 id가 같다. (인스턴스가 사실상 하나만 생성된 것)
    ```
- 개발자를 할거라면 `Design Pattern`을 잘 아는게 좋다.

### inheritance
- 상위 클래스의 `모든 것`을 하위 클래스가 물려받는 것
- 물려받는 클래스 
    - `Sub`,`Derived` Class
- 물려주는 클래스 
    - `Super`, `Based` Class
#### 단일 상속/다중 상속
- `단일 상속` : 하나의 클래스로부터 물려받음
- `다중 상속` : 여러 클래스로부터 물려받으면
    - JAVA,C++은 다중 상속을 지원하지 않는다. (Python은 지원함)
#### 상속의 목적
1. `여러 개의 클래스`에 `중복된 코드를 제거`하기 위해서
2. `제공되는 클래스`의 `기능을 확장`하기 위해
#### 형식
```python
class 클래스 이름(상위 클래스 이름 나열):
    pass
```
#### 예시 코드
```python
class Super:
    def greeting(self):
        print("상위 클래스")
class Sub(Super):
    def insa(self):
        print("하위 클래스")
sub = Sub()
sub.greeting() # 상위 클래스의 메서드까지 사용할 수 있다.
sub.insa()
```
- 특징
    1. Sub(하위 클래스)에서 `__init__`함수를 정의하지 않는 경우 아래와 같은 형태로 동작한다.
        ```python
        class Sub(Super):
            def __init__(self):
                super().__init__()
            def insa(self):
                print("하위 클래스")
        ```
        - 즉, super class의 init을 자동으로 실행한다.
            - 따라서 `super class의 init에서 매개변수를 요구하는 경우` 하위 클래스에서 `__init__`을 정의하지 않으면 `에러가 발생한다.`
                - Why? : 기본 `__init__()`에는 `super.__init__`에 매개변수를 전달하지 않기 때문



### 참고
1. 꼭 껍데기(Template)를 먼저 만들고 개발하자.
    - 껍데기를 만들고 개발해야 나중에 포폴낼 때도 할 말이 있다.
    - 의사소통도 원활하게 할 수 있다.
2. Customizing, Optimizing을 꼭 해보자
    - 학교 프로젝트는 단발성이기에 안하는 경우가 많다. 
        - 그런만큼 이런거까지 하면 엄청 좋아한다.
    - EX, logging system, super class 제작(부모 클래스 제작)
3. Method 이름이 is로 시작하면 무조건 True/False 값을 반환한다.
4. 같은 프로그램 내부에서 통신할 때는 메모리를 사용해서 통신한다.
    - 외부 프로그램 (네트워크, 파일)과 통신할때는 TCP,UDP 방식을 사용한다.
        - 이때 Token등을 사용해서 client의 수를 제한한다.
            - Server -> Client : Token 전송
            - Client -> Server : Token + Event 반납
            - 근데 이때, Client가 문제가 생기면, Server는 Token회수를 하지 못함.
                - 이를 해결하기 위해 `일정 시간마다 echo를 보내서 응답을 확인`함.(이 외에도 Timeout 등의 방식이 있다.)
                    - 응답 없으면 `자원을 즉시 해제`
5. 파일 핸들링, 네트워크 핸들링(네트워크,DB)은 `예외 처리가 필수`다.
    - 둘 다 나(프로그램)가 아닌 다른 프로세스와 통신하기 떄문이다.
        - 나는 내 프로그램에 대해서는 잘 알고있지만, 다른 프로세스의 상태는 알 수 없음
            - 따라서, 알 수 없는 에러에 대비하기 위해 `예외 처리 필수`