# 12월 24일

## 데이터베이스
> 컴퓨터의 `기억 능력`을 활용하여 `자료`를 `가공,저장,활용`하는 `일체의 기술`
> 용어 의미
> - Data : 자료를 의미하는 datum의 복수형
> - Base : 집합
> - 즉, 자료 여러개의 집합

### 데이터와 정보
1. 데이터 : 어떤 필요에 의해 수집했지만, `특정 목적을 위해 평가하거나 정제하지 않은 값`이나 `사실 또는 자료` 
2. 정보 : `수집한 데이터`를 `어떠한 목적을 위해 분석`하거나 `가공`하여 `가치를 추가`하거나, `새로운 의미`를 이끌어 낼 수 있는 결과
3. 지식 : 상호 연결된 `정보 패턴을 이해`하여 `이를 토대로 예측한 결과물`로 `정보에 기반한 규칙`, 획득한 `다양한 정보를 구조화`하여 `유의미한 정보로 분류`하고 `일반화 시킨 결과물`
4. 지혜 : 근본 원리에 대한 깊은 이해를 바탕으로 도출되는 `창의적 아이디어`

### 효율적 데이터 관리를 위한 조건
1. `데이터 통합`하여 관리
2. `일관된 방법`으로 관리
3. 데이터 `누락 및 중복 제거`
4. 여러 사용자가 `공동으로 실시간 사용 가능`
- 상황에 따라 다름 4번 정도가 중요  

### 데이터베이스 특징
1. 운영상 필요한 데이터를 `중복을 최소화`해서 `컴퓨터 기억 장치`내에 모아놓은 집합체
    - 즉, `사용하기 편리하도록` 만들어 놓은 `데이터의 집합`
2. 데이터의 `중복 없이` 서로 관련되어 있어, `관련된 모든 환경에서 사용`될 수 있는 `데이터들의 집합`
    - 데이터의 중복 -> 종속
        - 종속 : 어느 하나가 변경되었을 때, 다른 요소에 영향을 주는 것
            - 개발에서 종속은 매우 안 좋은 것, 이를 해결하기 위해 개발 디자인에서도 Controller-Service-Repository, MVC 패턴을 사용한다.
                - 최근 MVC패턴은 서버에서 View를 안하는 추세로 가서 사라지는 추세다.
        - 데이터의 중복(종속)을 최소화하여 관리할 수 있게 하는 것이 `데이터베이스`
3. 자료를 획득하여 체계적으로 `분류`, `정리`한 다음 컴퓨터에서 처리가 가능하도록 `전자적 형태로 저장`한 것
4. 하나의 주제와 관련된 `Data들의 모음`
5. `통합`, `저장`, `운영` 가능한 `공동 데이터`

### 데이터베이스 사용 목적
- Database를 이용한 Database 관리 시스템은 `파일 관리 시스템`이 갖는 `구조적 한계를 극복`하기 위해 고안되었다.
    - 구조적 한계
        - 중복 
        - 조회 불편
        - 변경 불편
        - 등
- `데이터와 응용프로그램 사이의 종속을 최소화`하기 위해 사용한다.
    - 파일 관리 시스템의 가장 큰 문제 : `데이터`와 `프로그램`의 밀접한 관계
        - 이를 제거하기 위해 데이터베이스 고안
    - 데이터를 저장하거나 검색하는 등의 `데이터 관련 기능`을 `데이터베이스 관리 시스템`이 전담하도록 함으로써, 파일 관리 시스템이 지닌 `데이터와 응용프로그램 사이의 종속성을 최소화`, 데이터 변경으로 인해 생기는 `프로그램의 수정, 관리를 최소화`할 수 있다.
- 데이터의 중복으로 인한 `비 일관성 최소화`하기 위해 사용된다.
    - `공통된 데이터 저장 공간을 사용`하기 때문에 `데이터의 중복`에서 발생하는 `비 일관성`을 최소화할 수 있다.

### 데이터베이스가 갖춰야 할 조건
1. 대용량 : `대규모의 데이터`를 무리없이 `저장`
2. 효율성 : `저장 구조를 정교하게 설계`하여, `불필요한 중복을 제거`하고, `치밀하게 관리`
    - 이를 통해 데이터베이스 유지에 사용되는 고가의 장비를 최대한 활용할 수 있다.
3. 무결성 : 데이터를 `오류없이 관리`하기 위해 `이중,삼중 안전 장치`가 필요하다.
4. 활용성 : `필요할 때 활용`할 수 있어야 한다.
5. 공유성 : `정보를 공유`할 수 있어야 한다.
    - 정보는 공유할 때 가치가 더 높아진다.
6. 보안성 : 인증받지 않은 `외부 침입자로부터 보호`해야 한다.

## DBMS(데이터베이스 관리 시스템)
> `방대한 양의 데이터`를 `편리하게 관리`하고, `효율적으로 저장`,`검색`할 수 있는 `환경을 제공`해주는 `소프트웨어`
> - 데이터베이스 : 데이터를 저장하고 있는 객체
> - DBMS : DB를 다루는 프로그램

### DBMS의 필요성
1. 생산성 향상
2. 기능성 향상
3. 신뢰성 향상
    - 확장성(scalability)과 부하 분산(load balancing)를 구현

### DBMS 기능
#### 정의 기능(Definition)
> Create, Alter, Drop, Truncate, Rename
- `데이터의 형태`, `구조`, `데이터베이스의 저장`에 관한 `내용을 정의`, `다양한 응용 프로그램`과 `데이터베이스`가 `서로 Interface`할 수 있는 방법 제공
- `하나의 물리적 구조의 Database`로 여러 사용자가 `다양한 형태의 데이터를 요청`해도 이를 지원할 수 있도록 적절한 `데이터베이스 구조를 정의`할 수 있는 기능
- 특징
    1. `모든 응용 프로그램이 요구하는 데이터 구조를 지원`할 수 있게 `Database의 논리적 구조`와 `그 특성`을 목표 DBMS가 `지원하는 데이터 모델에 맞게 기술`
    2. 데이터베이스를 `물리적 저장 장치에 저장`하는데 `필요한 명세 포함`
    3. 데이터의 `논리적 구조와 물리적 구조 사이`에 `변환이 가능`하도록 명세

#### 조작 기능(Manipulation)
> Select, Insert, Update, Delete (CRUD)
- 사용자의 요구에 따라 `검색`,`삽입`,`갱신`,`삭제` 등을 지원하는 기능
- 사용자와 DB 사이의 Interface를 위한 수단 제공
- 특징
    1. 사용하기 쉬움
    2. 명확하고 안전함
    3. 효율적임
- 참고
    1. 최근엔 select와 그 외(insert,update, delete)로 구분한다.
        - select : 동시에 가능
        - insert, update, delete : 동시에 불가
        - 이렇게 구분하는 것이 CQRS
            - CQRS : `Command Query Responsibility Segregation` (명령과 조회의 책임 분리)
                - 일반적으로는 조회와 명령(값에 영향을 줌)을 하나의 모델에서 수행했다.
                - CQRS는 `select` / `insert,update,delete`를 구분하여 아래의 장점을 취한다.
                    1. `성능 최적화` 
                        - DB `읽기 비율이 조회 비율보다 높다`. 읽기 작업만 조회 전용 DB에서 수행하면 읽기 성능을 높일 수 있다.
                    2. `확장성`
                        - 명령용 서버와 조회용 서버를 구분하여 트래픽에 맞게 각자 확장할 수 있다. (예를 들어, 조회가 폭주하는 경우 조회용 서버만 scale up/out)
                    3. `복잡도 감소`
                        - 데이터를 저장할 때 규칙과 화면에 보여줄 때 규칙이 다른 경우, CQRS를 적용하면 코드가 깔끔해진다.
                - CQRS의 단점
                    1. `구현 난이도`
                        - 시스템 구조가 복잡해지므로, 설계와 관리가 어렵다.
                    2. `데이터 일관성`
                        - 명령용, 조회용을 분리할 경우 데이터가 수정된 것이 반영되기까지의 딜레이가 생길 수 있어 `최종일관성`문제가 발생할 수 있다.
            - CQRS를 알고 적용을 해봤냐 안 해봤냐의 차이가 있으므로, 프로젝트는 CQRS를 적용해보기
    
#### 제어 기능(Control)
> grant, revoke, commit, rollback...
- DataBase의 내용에 대해 정확성과 안전성을 유지하는 기능 
    - 무결성 유지, 보안, 병행 수행 제어, 회복
- 특징
    1. Database를 접근하는 `갱신`, `삽입`, `삭제` 작업이 `정확하게 수행`되게 하여, `데이터의 무결성이 파괴되지 않도록` 제어한다.
    2. `정당한 사용자가 허가된 데이터에 접근`할 수 있게끔 `보안 유지` 및 `권한 검사`한다.
    3. 여러 사용자가 `Database`에 `동시에 접근`하여 데이터를 처리할 때, `Database와 처리 결과가 항상 정확`하도록 병행 제어한다.
    4. `Transaction을 수행`하는 도중 `장애`로 인해 `손상된 Database`를 `손상되기 이전의 정상적인 상태로 복구`시키는 작업

### DBMS의 역사
1. 1960년대 : 파일시스템, Flat-File,ISAM
2. 1970년대 : Network-DB, Hierarchical-DB
    - Network-DB
        - 계층형 데이터베이스의 `데이터 중복 문제`를 해결하기 위해 `레코드 간의 관계`를 그물처럼 갖는 구조, `다대다 관계` 지원
    - Hierarchical-DB
        - `디렉토리`와 `파일` 등을 계층적 구조로 저장
3. 1980년대 : 관계형-RDBMS
    - RDBMS
        - 데이터를 테이블 단위로 저장
4. 1990년대 : 관계형-RDBMS, 객체 지향형, 객체 관계형
    - 객체 지향 
        - 객체 그대로를 Database의 데이터로 저장
    - 객체 관계
        - 객체 지향의 장점을 RDBMS에 적용
5. 2000년대 : 분산파일시스템, NoSQL
    - 분산 파일 시스템 : Hadoop
    - NoSQL 
        - Key-Value Store : 키-값의 형식으로 단순하게 데이터를 저장하는 방식의 Database
            - 종류: Firebase Realtime Database, Redis 등
        - Document : 하나의 데이터를 하나의 문서로 취급하는 Database
            - 종류 : mongo DB
        - Big Table: Key-Value 형식을 확장한 개념, Column Family 라는 개념을 도입한 Database로 `Cassandra`, `Hbase`가 대표적

### RDBMS
- Database를 `테이블의 집합`으로 설명하는 DBMS
- 1970년 Codd에 의해 개발되었음
- 상용RDBMS는 `Oracle`, `MySQL`, IBM의 `DB2`, 마이크로소프트의 `MS-SQL Server`, Sybase를 포함한 SAP의 `HANA DB`, `TeraData Database`, `Tibero` 등이 있음
    - 추가로 취업을 위해 배울만한 DB로는 `HANA DB`, `Tibero`
- 오픈 소스 DBMS :  `MySQL`, `PostgreSQL`, `SQLite`, `MariaDB`
- 각 `DB의 특성`을 잘 이해하고, `목적에 맞는 DB를 잘 선택해서 쓰는 것이 중요`하다.

#### RDBMS 구성
1. `Relation` : 정보 저장에 기초가 되는 `2차원 구조의 테이블`, `개체(Entity)`라고도 한다.
    - 정의
        1. 행(row)과 열(column)으로 구성되는 2차원 구조
        2. 행 - 하나의 개체 / 열 - 개체의 속성 
        3. 행 - `튜플` / 열 - `속성(Attribute)`이라고 한다.
    - 특징
        1. 하나의 Relation에 있는 Tuple들은 모두 `Distinct`하다.
        2. 하나의 Relation에서 `Tuple의 순서`와 `Attribute들의 순서`는 없다.
        3. 하나의 Relation에서 `같은 이름`을 가진 `Attribute들`이 있을 순 없다.
        4. 각 Attribute가 가질 수 있는 값의 범위를 벗어난 값을 가지는 `Tuple`은 없다.
        5. 행과 열이 교차되는 곳은 `Atomic(원자값)으로 표현`한다. 
            - Q) Atomic(원자값)?
            - A) 논리적으로 `더 이상 쪼개질 수 없는 값`, 원자값으로 표현한다는 것은 `여러 개의 값을 갖는 속성을 직접 표현하는 것이 불가능함`을 의미
2. `Attribute`(속성) : 테이블의 각 `열`을 의미, `Column`이라고도 한다.
3. `Domain` : 속성이 가질 수 있는 값들의 집합
4. `Tuple` : 테이블이 `한 행을 구성하는 속성들의 집합`, `Row`,`Record`라고도 한다.
5. `Cardinality`(기수) : 하나의 테이블에서 `행의 수`나 서로 다른 테이블 사이에서 `대응되는 수`
6. `Degree`(차수) : 테이블에서 `속성의 수`
7. `Constraint`(제약 조건) : 데이터의 무결성을 지키기 위해 `데이터를 저장하고자 할 때` 실행되는 `검사 규칙`
#### RDBMS 개체
1. `Table` 
    - DB의 가장 `기본적인 저장 단위`
    - `실제 데이터`가 `물리적인 디스크 공간에 저장`되는 `유일한 개체`
2. `View` 
    - 하나 이상의 테이블로부터 유도된 `가상 테이블`
    - SELECT 쿼리문 자체를 저장
    - View를 조회하면, `저장된 쿼리문을 실행해 결과를 실시간`으로 보여준다.
    - 보안과 편의성, 조회 속도 향상을 위해 사용한다.
3. `Index` 
    - 데이터 검색 속도를 높이기 위해 `별도로 생성`하는 `색인`
    - 원리 : 특정 Column의 값을 정렬하여, 별도의 공간에 저장하고, 해당 값이 어느 위치(RowID)에 있는지 기록
    - 장점 : SELECT 속도 향상
    - 단점 
        1. INSERT, UPDATE, DELETE시에는 Index도 함께 갱신해야 하므로, `쓰기 성능은 저하`될 수 있다.
        2. 너무 많은 인덱스는 저장 공간 낭비를 초래한다.

4. `Synonym`
    - DB 개체에 대한 별명
    - 사용자명.테이블명 처럼 길게 써야 하는 이름을 짧게 줄여 사용하기 위해 제작
    - 생성 방식
        ```sql
        CREATE [OR REPLACE] [PUBLIC] SYNONYM 시노님 이름
        FOR 사용자명.[테이블/뷰/프로시저 이름]
        -- EX
        CREATE OR REPLACE SYNONYM test
        FOR root.test_table_20260101
        ```
        - PUBLIC
            - 이 부분을 안 적으면, `생성한 사용자만 사용` 가능한 SYNONYM 
            - PUBLIC을 적으면 `모든 사용자가 사용`할 수 있는 공용 SYNONYM
5. `Sequence` 
    - 순차적으로 증가하는 번호를 생성하는 개체
    - 주로, Primary Key를 자동 생성할 때 사용
6. `Anonymous Procedure`
    - 이름이 없는 `일회성 코드 블록`
    - DB에 저장되지 않음.
    - `선언 후, 즉시 실행`됨
    - `간단한 테스트`, `스크립트 작성에서 사용`된다.
7. `Stored Procedure`
    - 이름을 붙여 `저장해둔 SQL 문장들의 집합`
    - `매개변수`를 받을 수 있고, `복잡한 비즈니스 로직을 처리`하는데 사용
    - 필요할 때마다 호출하여 사용할 수 있어 `재사용성이 높음`
8. `Stored Function`
    - `특정 연산을 수행`하고 `결과를 반드시 반환`하는 개체
    - 프로시저와 유사하나, `SQL 구문 내`에서 `직접 호출`하여 `계산된 값을 얻는데 특화`
9. `Package`
    - 관련된 `프로시저, 함수, 변수` 등을 `하나로 묶어 관리`하는 `논리적 그룹`
    - 모듈화를 가능하게 함.
        - 유지보수가 쉬워짐
    - 사용시 `패키지 전체를 메모리에 로드`하므로, `속도 향상에 도움`된다.
10. `Trigger`
    - `특정 테이블`에 `DML`(INSERT,UPDATE,DELETE)가 `발생`할 때, `자동으로 실행`되는 코드
    - `데이터 무결성 유지`, `로그 기록 자동화`를 위해 사용

#### RDBMS 키(key)
- Relation을 구성하는 각 Tuple들을 `데이터 값에 의해 유일하게 식별할 수 있는 속성` 또는 `속성들의 집합`
    - 예시
        1. 학번
        2. {학번,이름} / {학번, 학과} / {학번, 이름, 학과}

- `슈퍼 키(Super Key)`
    - `속성의 개수와 상관없이` 다른 튜플과 `구분할 수 있는 속성` 또는 `속성의 집합`
    - 후보키보다 더 쉬운 조건 (`유일성만 만족하면 Super Key`)

- `후보 키(Candidate Key)`
    - Relation을 구성하는 Attribute들 중에서 `Tuple을 유일하게 식별하기 위해 사용하는 Attribute들의 부분 집합`
    - 후보 키의 조건
        1. `유일성`
            - 이 정보만 있으면 `무슨 Tuple인지 정확히 1개 집어낼 수 있다.`
        2. `최소성`
            - Tuple을 `정확히 1개 인지하는데 불필요한 Attribute는 제외`해야 한다.
            - 즉, `속성의 개수`가 `최소`
            - 여러 개를 합쳐도 되는데, 후보키를 포함해서 합치면 안된다.
                - 아래 예시 참고
    - 예를 들어, 학과, 이름, 학번 3개의 Attribute가 존재할 때, 학과와 이름만으로는 Tuple이 유일하지 않을 수 있다. (동명이인, 같은 학과) 하지만 학번은 Tuple모두가 다르기 때문에 유일한 값이다. 즉, 학번은 후보 키다. 
        - 만약 여기에 주민번호까지 총 4개의 Attribute가 있다고 가정하자.
            1. {학과,이름} -> 후보키 X
                - Y? 동명이인, 같은 학과
            2. {학번} -> 후보키 O
                - Y? 고유한 값 (유일성 만족), 학번만으로 구분 가능(최소성 만족)
            3. {학번, 이름} -> 후보키 X
                - Y? 최소성을 만족하지 못함.(이름은 불필요)
            4. {주민번호} -> 후보키 O
                - Y? 고유한 값 (유일성 만족), 주민번호만으로 구분 가능(최소성 만족)
            5. {학번, 주민번호} -> 후보키 X
                - Y? 고유한 값 (유일성 만족), 학번, 주민번호 2개가 있어야 구분 가능하지 않음 (아무거나 1개만 있어도 된다.)(최소성 불만족)
        - 만약 주소까지 있다고 가정하면
            1. {이름, 주소} -> 후보키 O
                - 같은 집에 이름이 같은 사람은 안 산다.
                - 따라서 두 개를 합쳐서 튜플 구분이 가능하므로 후보키임

- `기본 키(Primary Key)`
    - 후보키 중에서 `선정한 키` -> 개발자가 선정한다.
        - 즉 `기본키 in 후보키`
    - Relation의 `tuple`들을 `유일하게 식별`할 수 있는 키
    - 후보키 중 `기본키가 되지 못한 키`들은 `대체 키(Alternate Key)`라고 부른다.

- `외래 키(참조 키)(Foreign Key)`
    - 다른 테이블의 `행을 식별`할 수 있는 속성 
    - 다른 테이블의 unique한 Key면 된다.
        - 즉, 후보키면 가능
        - 복합키도 외래키로 사용할 수 있다.
        - 하지만 99%의 경우 `기본 키`를 외래키로 사용한다.
            - 기본 키가 아닌 것을 사용하면 나중에 가서 중복이 생기는 문제가 생길 수도 있기 때문(위험 방지) 

    - 설정 방법 : 양쪽 테이블 사이의 Cardinality를 파악하기
        1. `1:1 관계` : `양 쪽의 기본 키`를 서로 `반대 쪽의 외래 키로 추가`
            - EX, 사용자-사용자 프로필 : `사용자 테이블의 사용자 ID`를 `프로필의 외래키`로 이용
        2. `1:다 관계` : `한 쪽의 기본 키`를 `다른 여러 테이블에 외래 키`로 추가
            - N쪽 테이블에 1쪽의 기본 키를 외래 키로 추가
            - 즉, `1:1과 1:N의 차이`
                - 1:1 -> 자식 테이블에서 외래 키가 1번만 나타남 (즉 후보키가 됨)
                - 1:N -> 자식 테이블에서 외래 키가 여러 번 나타남 (즉 후보키가 될 수 없음)
            - EX, 부서-사원정보: 부서에는 많은 사원들이 존재함. `많은 사원들의 정보에 부서 테이블의 ID`가 들어감 
        3. `다:다 관계` : `양쪽의 기본 키`를 가지는 별도의 테이블 들을 생성해서 `외래 키`로 설정
            - EX, 학생-수강내역-교과목 : `학생과 교과목 테이블의 ID`를 `각각 외래키로 사용`하여 `수강내역 테이블을 구성`함

### 모델링

#### 데이터의 중복으로 인한 이상 현상
- 정규화
    - 테이블을 분리하는 것
    - 장점 : 삽입, 삭제, 갱신 빠름.
    - 단점 : 조회 느림
        - 조회할 때마다 `JOIN`작업을 해주어야 해서, 조회가 느리다.
        - 그래서 우린 정규화를 일단 진행하고, 성능을 보며, 역정규화를 해나간다.

- 역정규화
    - 테이블을 결합하는 것
    - 장점 : 조회 빠름
    - 단점 : 삽입, 삭제, 갱신 느림

- 변경 이상
    - 고칠려고 하는 것이 1개인데, `여러 번 수정`해야 하는 경우
        - 이는 `데이터 불일치를 야기`할 수 있다.

- 삽입 이상
    - 삽입할 수 없는 현상 , 삽입 이상
    - PK가 NULL이 되어 값을 INSERT할 수 없음

- 삭제 이상
    - 지우고싶은 정보가 있는데 정보를 삭제할 수 없음.

#### 함수적 종속
- 종류
    1. 완전 함수적
        - 기본키 전체를 가지고 종속
    2. 부분 함수적
        - 기본 키가 2개 이상으로 구성되었을 떄, 부분 집합에 종속되었을 때
    3. 이행적 종속 
        - X->Y, Y->Z 일때, X->Z인 경우
#### 정규화
- 1차 정규화
    - 모든 도메인은 `Atomic Value로 구성`되어야 한다.
        - `모든 셀`은 `하나의 값`만 가져야 한다. (즉, 2개 이상의 값을 표시한다면 별도의 행으로 분리한다.)
    - ex, 수강과목
        - 1차 정규화 전 : [알고리즘,DB]
        - 1차 정규화 후 : [알고리즘], [DB]
- 2차 정규화
    - `부분 함수적 종속성`을 제거하고 `모든 속성`이 `기본키`에 `완전 함수적 종속`이 되도록 한다.
        - `PK의 일부분에만 의존하는 속성`을 `별도 테이블로 분리`한다.
    - 예시,
        - 기본키 `{학번, 과목코드}`인 테이블에 `강의실` 정보가 있다 가정
        - 강의실 -> `학번`과 상관없음, `과목코드`에 의존
        - `{학번, 과목코드}` / `{과목코드, 강의실}` 2개의 테이블로 분리한다.
- 3차 정규화
    - `이행적 함수적 종속성`을 제거한다.
    - `기본키가 아닌 속성 간의 종속 관계`가 있는 경우 `테이블을 분리`
    - EX)
        - `학번(PK) -> 학과 코드 -> 학과명` 관계가 존재할 때,
        - `학과명`은 `학번`에 직접 종속이 아닌, `학과 코드`를 통해 종속된다.
        - `{학번,학과코드}`. `{학과 코드, 학과명}` 두 테이블로 분리한다.
- BCNF(보이스코드 정규화)
    - `결정자`이면서 `후보키`가 아닌 것을 제거한다.
    - `모든 결정자`가 `후보키`가 되도록 분리
    - 예시, 교수 한 명이 한 과목만 담당하는데, {학생, 과목}이 PK 가정
        - 이때 `교수`는 일반 속성이지만, `교수`가 한 과목만 가지므로 `과목에 대한 결정자`이다.
        - 이때, 테이블을 분리한다.
- 4차 정규화
    - `다치 종속 관계` 제거
    - 하나의 테이블 내에 서로 관련 없는 `독립적인 다대다 관계`가 `두 개 이상` 포함된 경우 분리
    - 예시, 교수 한 명이 여러 과목을 가르치고, 여러 연구 과제를 수행한다 가정
        - `{교수, 과목}` / `{교수,연구 과제}` 2개의 테이블로 분리
- 5차 정규화
    - Join 종속 관계를 제거
    - 테이블을 `분해`했다가 `다시 조인`했을 때, `데이터 손실이나 가짜 데이터가 생기지 않도록` `더 작게 분해`
    - 현실적으로 매우 드물다. 예시를 들기가 어려움(실제로 1~3차만 하는 경우가 대부분)


- 정규화 단점
    1. 빈번한 Join 연산의 증가
    2. 부자연스러운 DB Semantic 초래
        - 테이블만 보고 의미 파악이 어려움
    3. 조회/검색 위주에는 부적합하다.
- 업계 동향
    1. 온라인 처리 : 소규모 정규화
    2. 단순 조회용 데이터 : 비정규화
    3. 배치처리 (ex,은행) : 비정규화

#### 반정규화
- 정규화를 거치면, `Table이 많이 분리`된다. 이 상태에서 `복잡한 데이터 조회` 시, `많은 JOIN이 발생`해 `CPU와 메모리를 많이 소모`한다.(성능 저하)
    - 이 문제를 해결하기 위해 `반 정규화`를 통해 `시스템의 성능 향상 및 개발 운영의 단순화`를 만든다.
- 반 정규화 방식
    1. 테이블 추가
        - 통계 테이블 추가
            - SUM,AVG 등 자주 사용되는 연산 결과를 미리 수행하여 계산해둬서, 조회시 성능을 올려줌
        - 이력 테이블 추가
            - 특정 업무의 상태, 진행 흐름 관리를 위해 별도의 테이블 생성
            - EX, `주문 프로세스`의 현재 상태를 알기 위해 많은 JOIN이 필요한 경우, `최신 상태값만 관리`하는 `현재 주문 상태` 테이블을 별도로 추가
        - 중복 테이블 추가
            - 동일한 구조의 테이블을 `다른 서버`나 `다른 용도`로 하나 더 생성
        - 부분 테이블 추가
            - EX, 로그인이라면, 사용자 정보에서, id-pw만 따로 빼둔 부분 테이블을 추가하여, 로그인을 빨리 처리할 수 있음
    1. 테이블 통합
        - 두 테이블 사이에 JOIN이 빈번하게 발생할 때, 합치는 것
    2. 테이블 분활
        - 수직 분할
            - 한 테이블에 Column이 너무 많을 때, `자주 사용하는 Column`과 `그렇지 않은 Column`을 분리한다.
        - 수평 분할(파티셔닝)
            - `행이 너무 많을 때`, `날짜`,`지역` 별로 `테이블을 쪼개어 저장`한다.
    3. 중복 컬럼 추가
        - JOIN을 피하기 위해 `다른 테이블`에 있는 `Column을 현재 테이블에 복사`
    4. 파생 컬럼 추가
        - `계산이 필요한 값`을 `미리 계산`해서 `저장`해두는 방식
    

### 분산 데이터 베이스
- 여러 개의 데이터 베이스를 `네트워크로 연결`하여 `하나의 논리적 데이터베이스`처럼 인식되도록 관리하는 시스템
#### 분산 데이터 베이스의 4대 투명성
- 사용자가 내부 구조를 모르고도 이용할 수 있도록 보장해야 하는 성질
1. 위치 투명성
    - 데이터가 `어느 서버`에 저장되어 있는지 몰라도 `데이터 이름`만으로 접근 가능해야 한다.
2. 분할 투명성
    - `하나의 테이블`이 `여러 조각`으로 나뉘어 `여러 곳`에 저장되어도 사용자는 `하나의 테이블`로 인식한다.
3. 복제 투명성
    - 데이터가 `여러곳에 복제`되어 있어도 사용자는 `단일 데이터`처럼 관리하며 시스템이 자동으로 `일관성 유지`
4. 장애 투명성
    - `특정 지역의 서버`가 고장나도 `다른 지역의 데이터`를 통해 `시스템 전체`가 멈추지 않고 동작
#### 분산 데이터베이스 설계 방식
- 크게 2가지 방식으로 나눈다.
    1. 수평 분할
        - 테이블의 행(Row)을 기준으로 나눈다.
        - EX) 이용자 테이블에서 -> 서울 이용자는 서울 서버, 부산 이용자는 부산 서버
    2. 수직 분할
        - 테이블의 열(Column)을 기준으로 나눈다.
        - EX) 민감한 정보 Column은 A, 기본 정보 Column은 B서버
#### 분산 데이터 베이스 장점
1. `지역 자치성`
    - 각 지역에 맞는 데이터를 `가까운 곳에서 관리`하여 `처리 속도가 빠름`
2. `신뢰성/가용성`
    - 한 서버가 죽어도, 다른 서버가 있어 `중단 없는 서비스` 가능
3. `확장성`
    - 서버를 `추가(Scale-out)`하여 용량을 늘리기가 쉬움
#### 분산 데이터 베이스 단점
1. `관리 복잡성`
    - `여러 서버 간`의 `데이터 동기화`가 `매우 어려움`
2. `통신 비용`
    - 서버 간 데이터를 주고받는 `네트워크 비용`이 발생함
3. `설계 난이도`
    - `분산 트랜잭션 처리`를 위한 매커니즘이 복잡하다.
### 데이터 웨어하우스
- 의사 결정을 지원하기 위해 `여러 시스템에 흩어져 있는 데이터`를 통합하여 `정제`하고, `분석 가능한 상태로 저장`한 `분석 전용 데이터베이스`
#### 데이터 웨어하우스의 4대 특징
1. `주제 지향성`
    - 특정 주제별로 데이터를 구성
2. `통합성`
    - 서로 다른 형식의 데이터들을 `하나의 일관된 형식`으로 통합
3. `시계열성`
    - 과거부터 현재까지의 데이터를 쌓아두어 `시간에 따른 추이 분석` 가능
4. `비휘발성`
    - DW에 적재된 데이터는 `삭제/수정`하지 않고, `조회 용도`로 사용
#### 데이터 웨어하우스 아키텍처
1. `Data Source` : 운영 DB / 로그파일 / 외부 데이터 등
2. `ETL(Extract, Transform, Load)` : 데이터를 추출/변환/적재하는 단계
3. `Staging Area` : ETL 작업 중 데이터를 임시로 스테이징하는 공간
4. `Data Mart` : 특정 부서가 필요로 하는 데이터만 따로 추출해둔 작은 규모의 DW

#### 데이터 레이크, 데이터 레이크 하우스
- 데이터 레이크 
    - 정제되지 않은 Raw Data를 `형식에 상관없이` 모두 `저장하는 저장소`
- 데이터 레이크하우스
    - 데이터 레이크의 유연성 + 데이터 웨어하우스의 관리
    - Databricks, Snowflake 등

## Maria DB

### 작업 단위
- `Oracle` -> `User` (User > Database > Table)
- `MariaDB`,`MySQL` -> `Table`
    - Table이 가장 큰 작업 단위이기 때문에, 다른 User여도 Table 이름이 같을 수 없다.
- Table이름은 원래 `DB이름.테이블이름`으로 불려야 하지만, `현재 작업중인 테이블`의 경우, `DB이름 생략이 가능`하다.

### 설치
1. 기본적으로 `root는 local에서만 작업`할 수 있도록 해야 한다.
    - 다른 곳에서 하고 싶으면, 계정을 새로 만들어, 권한을 주는 것이 좋다.
2. port 번호 : 3306 (Default)
3. Buffer pool size 
    - 일반적으로 DB는 전용 컴퓨터가 있기에, 이 값을 `크게 설정`한다.
        - 이 값이 크면, 여러 명이 동시에 작업해도 렉이 없다.

### 명령어
- `show databases` : `데이터베이스 목록` 확인
- `select database()` : `현재 사용중인 데이터베이스` 확인
- `create database 이름` : `데이터베이스 생성`
- `use 이름` : 작업 중인 `데이터베이스 변경`
- `show tables` : 현재 작업중인 데이터베이스에 속한 `테이블 목록 확인`
- `drop database 이름` : `데이터베이스 삭제`
- `source 파일경로` : `sql 파일` 실행

```sql
show databases; -- DB 목록 확인
select database(); -- 현재 사용중인 DB 확인
create database kingrangE; -- kingrangE 이름의 DB 생성
use kingrangE; -- kingrangE DB 작업 설정
show tables; -- kingrangE DB에 속한 테이블 목록 확인
drop database kingrangE; -- kingrangE DB 삭제
```

### SELECT 

#### 기본 형식

```sql
SELECT 컬럼명들 
FROM 테이블명 
[WHERE 조건]
[GROUP BY 필드명]
[HAVING 그룹화 조건]
[ORDER BY 필드명]
[LIMIT 숫자](or LIMIT 숫자 OFFSET 건너뛸 숫자)
```


#### 중복 제거
- `DISTINCT` : SELECT 결과 중 중복되는 행을 삭제하는 예약어

```sql
SELECT DISTINCT name
FROM user;
--이름이 중복되면 1행으로 표현

SELECT DISTINCT product_name,user_name
FROM order;
-- 동일한 유저가 동일한 상품을 구매한 것은 중복 없이 1개로 표기
```

#### 별명 설정
- `AS` : 컬럼명을 별명으로 설정하도록 해주는 예약어

```sql
SELECT name AS "유저명"
FROM user;
-- name 컬럼을 유저명으로 사용
```

#### 연산신 출력
- SELECT 절에 COLUMN이름 대신 `연산식(+-*/%)`을 이용하는 것이 가능하다.

```sql
SELECT price*amount AS "총 구매금액"
FROM order;
```

#### 단순 계산식 출력
- 단순 계산식 출력의 경우 `FROM`을 생략해도 된다.

```sql
SELECT 24*365 AS "1년(h)"
```

#### 정렬
- 기본적으로 `MariaDB`는 `PK`를 가지고 `정렬`해서 `데이터를 조회`한다.
- 만약 다른 기준으로 정렬하고 싶다면, `ORDER BY`를 통해 수행한다.
- `ORDER BY`절의 형식
    - `[COLUMN이름 / 연산식][ASC/DESC]` 형태로 작성(ASC: 오름차순, DESC: 내림차순)
    - SELECT절에 나열한 COLUMN의 순서 정보를 사용할 수 있다.(SELECT a,b,c 나열했다면 순서대로 1,2,3으로 사용가능)
    - `ORDER BY`에 여러 COLUMN을 작성하면, 앞에서부터 우선권을 가져 정렬한다.
- 예시

    ```sql
    SELECT SAL,ENAME
    FROM emp
    ORDER BY SAL; -- SAL 컬럼 값을 기준으로 정렬
    ---
    SELECT SAL,ENAME
    FROM EMP
    ORDER BY 1; -- 1번(SAL)을 기준으로 정렬
    ---
    SELECT SAL,ENAME
    FROM EMP
    ORDER BY 1,2; -- SAL을 기준으로 정렬하고, SAL이 동일한 경우 ENAME을 기준으로 정렬한다.
    ```

- 정렬할 땐 정렬 기준을 `조회`하고 `앞에`두는 것이 좋다. (무엇을 기준으로 정렬했는지 `명확하게 파악 가능`)

### WHERE
- 읽을 `레코드(행)`의 `조건을 지정`
    - `읽기` 뿐만 아니라, `INSERT`,`DELETE`,`UPDATE`에도 `사용 가능`하다.
#### 기본 형식

```sql
WHERE 조건
```

#### 연산자
- `=`,`>`,`>=`,`<`,`<=`,`!=`,`<>`,`^=`
    - `!=,<>,^=` : 같지 않다 의미
- `NOT` : 부정
- `BETWEEN A AND B` : A이상 B 이하
    - 문자열, 날짜도 비교 가능
    - `x >= A AND x <= B` 보다 `높은 성능`
        - Y ? BETWEEN은 각각이 아니라 한 번에 진행하기 때문
    - 예시, tCity테이블에서 area가 700 이상 1000이하인 것
        ```sql
        select *
        from tCity
        WHERE area BETWEEN 700 AND 1000
        ```
- `IN` : 목록 포함 여부
    - `IN(목록)`을 이용하면 `목록` 중 `하나`를 조회
        - 즉, 요소 or 요소 or ...과 같은 의미

#### 주의
- `문자열`,`날짜`는 `작은 따옴표('')로` 감싸야 한다.
    - BUT, `MariaDB`, `MySQL`에서는 큰 따옴표도 가능하다.
- SQL 예약어 -> `대소문자 구분 X`
    - COLUMN 내에 저장된 문자열 -> `대소문자 구분 O`
    - BUT, MySQL, MariaDB에서는 조회 시에 구분하지 않는다. (DEFAULT)
        - 만약 구분하게 하고 싶다면, 아래처럼 하면 된다.
            ```sql
            CREATE TABLE 테이블명(
                (대소문자 구분하게 하고싶은)컬럼이름 자료형 COLLATE utf8mb4_bin, 
                -- 이렇게 _bin으로 설정하면 BINARY 취급되어 구분한다.
                -- 기본 값은 _ci(Case Insensitive)로 대소문자 구분을 하지 않는다.
            )
            ```   
        - `기존 테이블의 컬럼`을 `대소문자 구분하도록 변경`하고싶다면     
            ```sql
            ALTER TABLE 테이블명 MODIFY 컬럼이름 자료형 COLLATE utf8mb4_bin
            ```
- NULL을 확인할 때
    - NULL은 일반 값과 다르게 `비트맵의 값`으로 `판별`한다.
    - 따라서 `=`,`!=`로 비교하는 것이 아닌, `IS`,`IS NOT`으로 비교한다.
    - EX, age가 NULL인 user 조회
        ```sql
        SELECT *
        FROM user
        WHERE age IS NULL -- 맞았음
        WHERE age = NULL -- 틀렸음
        ```

#### AND/OR/NOT
- AND : 모두 참일 때, 참
- OR : 모두 거짓일 때, 거짓
- NOT : 부정
- 우선 순위 : `NOT > AND > OR`
    - 이 우선순위를 기억해서 `쿼리 최적화`
        - 먼저 계산하는 조건에서 많이 거를 수록 조회 성능이 올라간다.

#### LIKE
- 패턴으로 `부분 문자열` 검색
- LIKE를 통해 `와일드카드`가 `사용 가능`하다.
    - 와일드 카드
        - `%` : 글자 수 상관 없음을 의미 (가변 길이 매칭)
            - `~로 시작하는` / `~로 끝나는` / `포함됨`을 검색할 때 사용
        - `_` : 1개의 문자를 의미 (고정 길이 매칭)
            - 특정 자릿수를 엄격하게 제한할 때 사용한다.
        - `ESCAPE` : 와일드카드 문자(`%`,`_`)가 데이터 내용에 포함되어 검색에 사용하고 싶을 때 사용하는 구문
            - 기본적으로는 역슬래시(`\`)가 `이스케이프 문자로 설정`되어 있다.
            - 하지만, `ESCAPE 구문을 이용`하여 `내가 원하는 문자로 변경`할 수 있다.
    - 예시,
        1. (`%`) tCity 테이블에서 name에 `길`이 포함된 데이터를 조회
            ```sql
            SELECT *
            FROM tCity
            WHERE name LIKE '%길%';
            ```
        2. (`%`) tCity 테이블에서 name에 `전`으로 시작하는 데이터를 조회
            ```sql
            SELECT *
            FROM tCity
            WHERE name LIKE '전%';
            ```
        3. (`%`) tCity 테이블에서 name에 `원`으로 끝나는 데이터를 조회
            ```sql
            SELECT *
            FROM tCity
            WHERE name LIKE '%원';
            ```
        4. (`_`) EMP 테이블에서 봉급이 3자리인 데이터 조회
            ```sql
            SELECT *
            FROM EMP
            WHERE SAL LIKE '___';
            ```
        5. (`_`) EMP 테이블에서 입사년도가 19xx년도인 데이터 조회
            ```sql
            SELECT *
            FROM EMP
            WHERE HIREDATE LIKE '19__';
            ```
        6. (`_`) EMP 테이블에서 이름이 전길로 시작하는 데이터 조회 (이름은 3글자)
            ```sql
            SELECT *
            FROM EMP
            WHERE ENAME LIKE '전길_';
            ```
        7. (`이스케이프 문자`) PRODUCT 테이블에서 할인율이 20%인 데이터 확인
            ```sql
            SELECT *
            FROM PRODUCT
            WHERE SALE LIKE '20\%';
            ```
        8. (`이스케이프 문자`) PRODUCT 테이블에서 할인율이 20%인 데이터 확인
            ```sql
            SELECT *
            FROM PRODUCT
            WHERE SALE LIKE '20#%' ESCAPE #;
            ```

### LIMIT
- 행의 개수 제한에 사용
- SELECT 구문의 마지막에 작성하여 `조회할 개수`를 표시한다.
- `ORDER BY`로 `정렬 수행` 후 작업하는 것이 좋다.
#### 기본 형식

```sql
SELECT 컬럼들
FROM 테이블명
LIMIT 조회하고싶은 행의 수 OFFSET 건너뛰고 싶은 행의 수 
LIMIT [건너뛸 개수,] 조회하고 싶은 행의 수
```

#### 예시

1. tCity 테이블에서 area 상위 4개의 데이터
```sql
SELECT *
FROM tCity
ORDER BY area
LIMIT 4
```

2. tCity 테이블에서 popu 4~6등까지
```sql
SELECT *
FROM tCity
ORDER BY popu
LIMIT 3,3 -- 또는 LIMIT 3 OFFSET 3
```

### 검색 결과 파일로 저장
#### 형식
```sql
-- 파일 경로에 저장
SELECT ... INTO OUTFILE '파일경로'
[CHARACTER SET 인코딩 방식]
[export_options]
```
```sql
-- 변수에 저장
SELECT ... INTO OUTFILE 변수명
```
```sql
-- SELECT 결과에 BLOB 타입의 데이터가 있는 경우
SELECT ... INTO DUMPFILE '파일 경로'
```

### SQL 실행 순서
```SQL
FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY -> OFFSET -> LIMIT 
```

### FUNCTION
> 특정 연산을 수행하고 그 결과를 반환하는 재사용 가능한 코드 블록
>> 복잡한 계싼이나 반복되는 로직을 `캡슐화`하여 쿼리를 간결하게 만드는데 핵심

#### 종류
1. 내장함수
    - 대부분의 DBMS에서 제공하는 함수
    - 단일행 함수(Scala Function) : 각 행에 대해 `개별적으로 적용`되어 `하나의 결과` 반환
        - 문자 함수 : `UPPER()`, `LOWER()`, `SUBSTR()`, `LENGTH()`
        - 숫자 함수 : `ROUND()`, `ABS()`, `CEIL()`, `FLOOR()`
        - 날짜 함수 : `NOW()`, `DATE_FORMAT()`, `SYSDATE()`
        - 변환 함수 : `CAST()`, `CONVERT()`, `TO_CHAR()`
    - 집계함수 (Aggregate Function) : `여러 행의 데이터를 그룹화`하여 `하나의 요약된 결과`를 반환
        - `NULL이 아닌 데이터`를 `그룹화`해서 집계함.
            - `그룹화`해서 집계하므로, `WHERE`에서는 `사용이 불가`하다. (실행 순서상 WHERE->GROUP BY)
        - `SUM()`
        - `AVG()`
        - `COUNT()`
        - `MAX()`
        - `MIN()`

2. 사용자 정의 함수
    - 표준 함수만으로 해결이 어려워 직접 생성하는 함수
    - 생성 형식
        ```sql
        DELIMITER //
        CREATE FUNCTION 함수이름(매개변수명 타입,매개변수명 타입,...)
        RETURNS 반환 타입
        DETERMINISTIC -- 선택적, 동일한 입력에 대해 항상 동일한 결과를 반환함을 명시하는 것
        BEGIN
            DECLARE 변수명 타입
            --비즈니스 로직
            SET 변수명=계산시기
            RETURN 변수명;
        END //
        DELIMITER ;
        ```
    - 프로시저와의 차이
        - 프로시저 
            - 반환 값 : `없거나`, `여러개`도 가능
            - 호출 위치 : `CALL 명령어`로 `별도 실행`
            - 목적 : 일련의 실행 절차`(프로세스)처리`
        - 함수
            - 반환 값 : 반드시 `1개`
            - 호출 위치 : SELECT, WHERE 등 `SQL 문장에 포함 가능`
            - 목적 : `값 계산 및 변환`

### 타입 변환
- 서로 다른 데이터 타입을 가진 값들을 `연산`,`비교`할 때 `데이터 타입`을 일치시키는 과정
#### 묵시적 형변환
- 직접 `변환 함수`를 쓰지 않아도 `DB`가 `자동으로 타입을 변환`
- 단점 : `의도치 않은 결과`를 얻을 수 있고, `성능에 악영향`(인덱스 미사용 등)을 줄 수 있음
    - EX, WHERE절에서 인덱스가 걸린 Column의 타입을 묵시적 변환하게 되면, 인덱스를 타지 못해 Full Scan을 하게 되어 속도가 느려진다.
- 예시
    ```sql
    SELECT '100' + 10; -- 문자열 + 숫자이지만, 결과는 110 정수로 나온다.
    ```
#### 명시적 형변환
- 개발자가 `함수를 사용`하여 `직접 타입을 지정`하는 방식, `가독성`이 좋아지고,`오류 방지`가능하다.
- 변환함수
    1. `CAST()` : ANSI SQL 표준함수, 데이터 형식을 다른 형식으로 `강제 변환`
        - 예시, 숫자 -> 문자
            ```sql
            CAST(123 AS CHAR) -- '123'
            ```
        - 예시2, 실수 -> 정수
            ```sql
            CAST(123.123 AS UNSIGNED) -- 123
            ```
    2. `CONVERT()` : CAST와 유사하나, `데이터 타입 변환` 뿐 아니라, `문자셋 변경`에도 사용
        - 예시, 문자열 -> utf8mb4 형식으로 변경
            ```sql
            CONVERT('123' USING utf8mb4);
            ```
        - 예시, 날짜 -> 문자열
            ```sql
            CONVERT(NOW(),CHAR)
            ```
    3. `TO_CHAR()` : `숫자, 날짜 데이터`를 `특정 포맷의 문자열`로 변경 (Oracle, Postgre 주로 사용)
    4. `TO_NUMBER()` : 숫자 형태의 `문자열`을 `숫자로` 변경
    5. `TO_DATE()` : `문자열`을 `날짜 타입`으로 변경

- 참고
    - `LIKE 연산자 사용`시 `성능상 주의할 점이 존재`한다.0
        1. `전방 일치` : INDEX를 탈 수 있어, `검색 속도`가 빠르다.
            - Y? 기본적으로 INDEX는 사전순으로 정렬되어 있다. 예를 들어, `30%`로 검색하면 30이 나타날 때까지는 건너뛸 수 있다.(`INDEX RANGE SCAN`)
        2. `후방/부분 일치` : INDEX를 효율적으로 사용하지 못하고, `전체 테이블 스캔`을 할 가능성이 높다.
            - Y? 후방/부분 일치는 값을 하나하나 확인해야 알 수 있다. 즉, `INDEX RANGE SCAN`이 안되기 때문에 `속도가 낮을 가능성`이 높다.


## 참고
1. 일반적으로 DB는 프로젝트 당 1개를 만든다.
2. MySQL, MariaDB -> Column이나 테이블 명, 예약어도 대소문자 구분안함
3. DB, 네트워크 명령어는 메모장에 적고, 시뮬레이터 같은 것으로 검증한 후, 실제 DB에서 실행하는 것이 좋다.
    - 어떤 문제가 일어날지 모르기 때문 (ex, 데이터 유실 등)
4. 영어와 다르게 다른 문자들은 인코딩에 따라 깨지는 이유
    - 영어 : ASCII 코드로 정해진 숫자가 모든 인코딩 방식에서 동일하다.
        - 인코딩 방식에 따라 `표현 비트`가 달라진다. 그러나 영어는 항상 65로 동일(비트가 늘어나면 앞을 0으로 채워 동일한 값으로 유지함)
        - ex, 65 : A(0100 0001) -> 16비트로 늘어나도 (0000 0000 0100 0001)이 되어 65가 된다.
    - 그 외의 언어 : 자기네 마음대로 인코딩 방식에 따라 표현 방식이 달라진다.
        - 예를 들어, ㄱ이 utf8에서는 0100 1010 0010 0111 이라고 가정하면, CP949 에서는 1011 0101 1100 0000 일 수 있다는 것이다.
5. utf-8 / utf8mb4 차이
    - utf-8 : 전세계 문자 사용 인코딩 (이모지 제외)
    - utf8mb4 : utf8 + 이모지

