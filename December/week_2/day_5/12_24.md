# 12월 24일

## 데이터베이스
> 컴퓨터의 `기억 능력`을 활용하여 `자료`를 `가공,저장,활용`하는 `일체의 기술`
> 용어 의미
> - Data : 자료를 의미하는 datum의 복수형
> - Base : 집합
> - 즉, 자료 여러개의 집합

### 데이터와 정보
1. 데이터 : 어떤 필요에 의해 수집했지만, `특정 목적을 위해 평가하거나 정제하지 않은 값`이나 `사실 또는 자료` 
2. 정보 : `수집한 데이터`를 `어떠한 목적을 위해 분석`하거나 `가공`하여 `가치를 추가`하거나, `새로운 의미`를 이끌어 낼 수 있는 결과
3. 지식 : 상호 연결된 `정보 패턴을 이해`하여 `이를 토대로 예측한 결과물`로 `정보에 기반한 규칙`, 획득한 `다양한 정보를 구조화`하여 `유의미한 정보로 분류`하고 `일반화 시킨 결과물`
4. 지혜 : 근본 원리에 대한 깊은 이해를 바탕으로 도출되는 `창의적 아이디어`

### 효율적 데이터 관리를 위한 조건
1. `데이터 통합`하여 관리
2. `일관된 방법`으로 관리
3. 데이터 `누락 및 중복 제거`
4. 여러 사용자가 `공동으로 실시간 사용 가능`
- 상황에 따라 다름 4번 정도가 중요  

### 데이터베이스 특징
1. 운영상 필요한 데이터를 `중복을 최소화`해서 `컴퓨터 기억 장치`내에 모아놓은 집합체
    - 즉, `사용하기 편리하도록` 만들어 놓은 `데이터의 집합`
2. 데이터의 `중복 없이` 서로 관련되어 있어, `관련된 모든 환경에서 사용`될 수 있는 `데이터들의 집합`
    - 데이터의 중복 -> 종속
        - 종속 : 어느 하나가 변경되었을 때, 다른 요소에 영향을 주는 것
            - 개발에서 종속은 매우 안 좋은 것, 이를 해결하기 위해 개발 디자인에서도 Controller-Service-Repository, MVC 패턴을 사용한다.
                - 최근 MVC패턴은 서버에서 View를 안하는 추세로 가서 사라지는 추세다.
        - 데이터의 중복(종속)을 최소화하여 관리할 수 있게 하는 것이 `데이터베이스`
3. 자료를 획득하여 체계적으로 `분류`, `정리`한 다음 컴퓨터에서 처리가 가능하도록 `전자적 형태로 저장`한 것
4. 하나의 주제와 관련된 `Data들의 모음`
5. `통합`, `저장`, `운영` 가능한 `공동 데이터`

### 데이터베이스 사용 목적
- Database를 이용한 Database 관리 시스템은 `파일 관리 시스템`이 갖는 `구조적 한계를 극복`하기 위해 고안되었다.
    - 구조적 한계
        - 중복 
        - 조회 불편
        - 변경 불편
        - 등
- `데이터와 응용프로그램 사이의 종속을 최소화`하기 위해 사용한다.
    - 파일 관리 시스템의 가장 큰 문제 : `데이터`와 `프로그램`의 밀접한 관계
        - 이를 제거하기 위해 데이터베이스 고안
    - 데이터를 저장하거나 검색하는 등의 `데이터 관련 기능`을 `데이터베이스 관리 시스템`이 전담하도록 함으로써, 파일 관리 시스템이 지닌 `데이터와 응용프로그램 사이의 종속성을 최소화`, 데이터 변경으로 인해 생기는 `프로그램의 수정, 관리를 최소화`할 수 있다.
- 데이터의 중복으로 인한 `비 일관성 최소화`하기 위해 사용된다.
    - `공통된 데이터 저장 공간을 사용`하기 때문에 `데이터의 중복`에서 발생하는 `비 일관성`을 최소화할 수 있다.

### 데이터베이스가 갖춰야 할 조건
1. 대용량 : `대규모의 데이터`를 무리없이 `저장`
2. 효율성 : `저장 구조를 정교하게 설계`하여, `불필요한 중복을 제거`하고, `치밀하게 관리`
    - 이를 통해 데이터베이스 유지에 사용되는 고가의 장비를 최대한 활용할 수 있다.
3. 무결성 : 데이터를 `오류없이 관리`하기 위해 `이중,삼중 안전 장치`가 필요하다.
4. 활용성 : `필요할 때 활용`할 수 있어야 한다.
5. 공유성 : `정보를 공유`할 수 있어야 한다.
    - 정보는 공유할 때 가치가 더 높아진다.
6. 보안성 : 인증받지 않은 `외부 침입자로부터 보호`해야 한다.

## DBMS(데이터베이스 관리 시스템)
> `방대한 양의 데이터`를 `편리하게 관리`하고, `효율적으로 저장`,`검색`할 수 있는 `환경을 제공`해주는 `소프트웨어`
> - 데이터베이스 : 데이터를 저장하고 있는 객체
> - DBMS : DB를 다루는 프로그램

### DBMS의 필요성
1. 생산성 향상
2. 기능성 향상
3. 신뢰성 향상
    - 확장성(scalability)과 부하 분산(load balancing)를 구현

### DBMS 기능
#### 정의 기능(Definition)
> Create, Alter, Drop, Truncate, Rename
- `데이터의 형태`, `구조`, `데이터베이스의 저장`에 관한 `내용을 정의`, `다양한 응용 프로그램`과 `데이터베이스`가 `서로 Interface`할 수 있는 방법 제공
- `하나의 물리적 구조의 Database`로 여러 사용자가 `다양한 형태의 데이터를 요청`해도 이를 지원할 수 있도록 적절한 `데이터베이스 구조를 정의`할 수 있는 기능
- 특징
    1. `모든 응용 프로그램이 요구하는 데이터 구조를 지원`할 수 있게 `Database의 논리적 구조`와 `그 특성`을 목표 DBMS가 `지원하는 데이터 모델에 맞게 기술`
    2. 데이터베이스를 `물리적 저장 장치에 저장`하는데 `필요한 명세 포함`
    3. 데이터의 `논리적 구조와 물리적 구조 사이`에 `변환이 가능`하도록 명세

#### 조작 기능(Manipulation)
> Select, Insert, Update, Delete (CRUD)
- 사용자의 요구에 따라 `검색`,`삽입`,`갱신`,`삭제` 등을 지원하는 기능
- 사용자와 DB 사이의 Interface를 위한 수단 제공
- 특징
    1. 사용하기 쉬움
    2. 명확하고 안전함
    3. 효율적임
- 참고
    1. 최근엔 select와 그 외(insert,update, delete)로 구분한다.
        - select : 동시에 가능
        - insert, update, delete : 동시에 불가
        - 이렇게 구분하는 것이 CQRS
            - CQRS : `Command Query Responsibility Segregation` (명령과 조회의 책임 분리)
                - 일반적으로는 조회와 명령(값에 영향을 줌)을 하나의 모델에서 수행했다.
                - CQRS는 `select` / `insert,update,delete`를 구분하여 아래의 장점을 취한다.
                    1. `성능 최적화` 
                        - DB `읽기 비율이 조회 비율보다 높다`. 읽기 작업만 조회 전용 DB에서 수행하면 읽기 성능을 높일 수 있다.
                    2. `확장성`
                        - 명령용 서버와 조회용 서버를 구분하여 트래픽에 맞게 각자 확장할 수 있다. (예를 들어, 조회가 폭주하는 경우 조회용 서버만 scale up/out)
                    3. `복잡도 감소`
                        - 데이터를 저장할 때 규칙과 화면에 보여줄 때 규칙이 다른 경우, CQRS를 적용하면 코드가 깔끔해진다.
                - CQRS의 단점
                    1. `구현 난이도`
                        - 시스템 구조가 복잡해지므로, 설계와 관리가 어렵다.
                    2. `데이터 일관성`
                        - 명령용, 조회용을 분리할 경우 데이터가 수정된 것이 반영되기까지의 딜레이가 생길 수 있어 `최종일관성`문제가 발생할 수 있다.
            - CQRS를 알고 적용을 해봤냐 안 해봤냐의 차이가 있으므로, 프로젝트는 CQRS를 적용해보기
    
#### 제어 기능(Control)
> grant, revoke, commit, rollback...
- DataBase의 내용에 대해 정확성과 안전성을 유지하는 기능 
    - 무결성 유지, 보안, 병행 수행 제어, 회복
- 특징
    1. Database를 접근하는 `갱신`, `삽입`, `삭제` 작업이 `정확하게 수행`되게 하여, `데이터의 무결성이 파괴되지 않도록` 제어한다.
    2. `정당한 사용자가 허가된 데이터에 접근`할 수 있게끔 `보안 유지` 및 `권한 검사`한다.
    3. 여러 사용자가 `Database`에 `동시에 접근`하여 데이터를 처리할 때, `Database와 처리 결과가 항상 정확`하도록 병행 제어한다.
    4. `Transaction을 수행`하는 도중 `장애`로 인해 `손상된 Database`를 `손상되기 이전의 정상적인 상태로 복구`시키는 작업

### DBMS의 역사
1. 1960년대 : 파일시스템, Flat-File,ISAM
2. 1970년대 : Network-DB, Hierarchical-DB
    - Network-DB
        - 계층형 데이터베이스의 `데이터 중복 문제`를 해결하기 위해 `레코드 간의 관계`를 그물처럼 갖는 구조, `다대다 관계` 지원
    - Hierarchical-DB
        - `디렉토리`와 `파일` 등을 계층적 구조로 저장
3. 1980년대 : 관계형-RDBMS
    - RDBMS
        - 데이터를 테이블 단위로 저장
4. 1990년대 : 관계형-RDBMS, 객체 지향형, 객체 관계형
    - 객체 지향 
        - 객체 그대로를 Database의 데이터로 저장
    - 객체 관계
        - 객체 지향의 장점을 RDBMS에 적용
5. 2000년대 : 분산파일시스템, NoSQL
    - 분산 파일 시스템 : Hadoop
    - NoSQL 
        - Key-Value Store : 키-값의 형식으로 단순하게 데이터를 저장하는 방식의 Database
            - 종류: Firebase Realtime Database, Redis 등
        - Document : 하나의 데이터를 하나의 문서로 취급하는 Database
            - 종류 : mongo DB
        - Big Table: Key-Value 형식을 확장한 개념, Column Family 라는 개념을 도입한 Database로 `Cassandra`, `Hbase`가 대표적

### RDBMS
- Database를 `테이블의 집합`으로 설명하는 DBMS
- 1970년 Codd에 의해 개발되었음
- 상용RDBMS는 `Oracle`, `MySQL`, IBM의 `DB2`, 마이크로소프트의 `MS-SQL Server`, Sybase를 포함한 SAP의 `HANA DB`, `TeraData Database`, `Tibero` 등이 있음
    - 추가로 취업을 위해 배울만한 DB로는 `HANA DB`, `Tibero`
- 오픈 소스 DBMS :  `MySQL`, `PostgreSQL`, `SQLite`, `MariaDB`
- 각 `DB의 특성`을 잘 이해하고, `목적에 맞는 DB를 잘 선택해서 쓰는 것이 중요`하다.

#### RDBMS 구성
1. `Relation` : 정보 저장에 기초가 되는 `2차원 구조의 테이블`, `개체(Entity)`라고도 한다.
    - 정의
        1. 행(row)과 열(column)으로 구성되는 2차원 구조
        2. 행 - 하나의 개체 / 열 - 개체의 속성 
        3. 행 - `튜플` / 열 - `속성(Attribute)`이라고 한다.
    - 특징
        1. 하나의 Relation에 있는 Tuple들은 모두 `Distinct`하다.
        2. 하나의 Relation에서 `Tuple의 순서`와 `Attribute들의 순서`는 없다.
        3. 하나의 Relation에서 `같은 이름`을 가진 `Attribute들`이 있을 순 없다.
        4. 각 Attribute가 가질 수 있는 값의 범위를 벗어난 값을 가지는 `Tuple`은 없다.
        5. 행과 열이 교차되는 곳은 `Atomic(원자값)으로 표현`한다. 
            - Q) Atomic(원자값)?
            - A) 논리적으로 `더 이상 쪼개질 수 없는 값`, 원자값으로 표현한다는 것은 `여러 개의 값을 갖는 속성을 직접 표현하는 것이 불가능함`을 의미
2. `Attribute`(속성) : 테이블의 각 `열`을 의미, `Column`이라고도 한다.
3. `Domain` : 속성이 가질 수 있는 값들의 집합
4. `Tuple` : 테이블이 `한 행을 구성하는 속성들의 집합`, `Row`,`Record`라고도 한다.
5. `Cardinality`(기수) : 하나의 테이블에서 `행의 수`나 서로 다른 테이블 사이에서 `대응되는 수`
6. `Degree`(차수) : 테이블에서 `속성의 수`
7. `Constraint`(제약 조건) : 데이터의 무결성을 지키기 위해 `데이터를 저장하고자 할 때` 실행되는 `검사 규칙`

#### RDBMS 키(key)
- Relation을 구성하는 각 Tuple들을 `데이터 값에 의해 유일하게 식별할 수 있는 속성` 또는 `속성들의 집합`
    - 예시
        1. 학번
        2. {학번,이름} / {학번, 학과} / {학번, 이름, 학과}

- `슈퍼 키(Super Key)`
    - `속성의 개수와 상관없이` 다른 튜플과 `구분할 수 있는 속성` 또는 `속성의 집합`
    - 후보키보다 더 쉬운 조건 (`유일성만 만족하면 Super Key`)

- `후보 키(Candidate Key)`
    - Relation을 구성하는 Attribute들 중에서 `Tuple을 유일하게 식별하기 위해 사용하는 Attribute들의 부분 집합`
    - 후보 키의 조건
        1. `유일성`
            - 이 정보만 있으면 `무슨 Tuple인지 정확히 1개 집어낼 수 있다.`
        2. `최소성`
            - Tuple을 `정확히 1개 인지하는데 불필요한 Attribute는 제외`해야 한다.
            - 즉, `속성의 개수`가 `최소`
            - 여러 개를 합쳐도 되는데, 후보키를 포함해서 합치면 안된다.
                - 아래 예시 참고
    - 예를 들어, 학과, 이름, 학번 3개의 Attribute가 존재할 때, 학과와 이름만으로는 Tuple이 유일하지 않을 수 있다. (동명이인, 같은 학과) 하지만 학번은 Tuple모두가 다르기 때문에 유일한 값이다. 즉, 학번은 후보 키다. 
        - 만약 여기에 주민번호까지 총 4개의 Attribute가 있다고 가정하자.
            1. {학과,이름} -> 후보키 X
                - Y? 동명이인, 같은 학과
            2. {학번} -> 후보키 O
                - Y? 고유한 값 (유일성 만족), 학번만으로 구분 가능(최소성 만족)
            3. {학번, 이름} -> 후보키 X
                - Y? 최소성을 만족하지 못함.(이름은 불필요)
            4. {주민번호} -> 후보키 O
                - Y? 고유한 값 (유일성 만족), 주민번호만으로 구분 가능(최소성 만족)
            5. {학번, 주민번호} -> 후보키 X
                - Y? 고유한 값 (유일성 만족), 학번, 주민번호 2개가 있어야 구분 가능하지 않음 (아무거나 1개만 있어도 된다.)(최소성 불만족)
        - 만약 주소까지 있다고 가정하면
            1. {이름, 주소} -> 후보키 O
                - 같은 집에 이름이 같은 사람은 안 산다.
                - 따라서 두 개를 합쳐서 튜플 구분이 가능하므로 후보키임

- `기본 키(Primary Key)`
    - 후보키 중에서 `선정한 키` -> 개발자가 선정한다.
        - 즉 `기본키 in 후보키`
    - Relation의 `tuple`들을 `유일하게 식별`할 수 있는 키
    - 후보키 중 `기본키가 되지 못한 키`들은 `대체 키(Alternate Key)`라고 부른다.

- `외래 키(참조 키)(Foreign Key)`
    - 다른 테이블의 `행을 식별`할 수 있는 속성 
    

    - 다른 테이블의 unique한 Key면 된다.
        - 즉, 후보키면 가능
        - 복합키도 외래키로 사용할 수 있다.
        - 하지만 99%의 경우 `기본 키`를 외래키로 사용한다.
            - 기본 키가 아닌 것을 사용하면 나중에 가서 중복이 생기는 문제가 생길 수도 있기 때문(위험 방지) 

    - 설정 방법 : 양쪽 테이블 사이의 Cardinality를 파악하기
        1. `1:1 관계` : `양 쪽의 기본 키`를 서로 `반대 쪽의 외래 키로 추가`
            - EX, 사용자-사용자 프로필 : `사용자 테이블의 사용자 ID`를 `프로필의 외래키`로 이용
        2. `1:다 관계` : `한 쪽의 기본 키`를 `다른 여러 테이블에 외래 키`로 추가
            - N쪽 테이블에 1쪽의 기본 키를 외래 키로 추가
            - 즉, `1:1과 1:N의 차이`
                - 1:1 -> 자식 테이블에서 외래 키가 1번만 나타남 (즉 후보키가 됨)
                - 1:N -> 자식 테이블에서 외래 키가 여러 번 나타남 (즉 후보키가 될 수 없음)
            - EX, 부서-사원정보: 부서에는 많은 사원들이 존재함. `많은 사원들의 정보에 부서 테이블의 ID`가 들어감 
        3. `다:다 관계` : `양쪽의 기본 키`를 가지는 별도의 테이블 들을 생성해서 `외래 키`로 설정
            - EX, 학생-수강내역-교과목 : `학생과 교과목 테이블의 ID`를 `각각 외래키로 사용`하여 `수강내역 테이블을 구성`함

### 모델링
#### 데이터 모델

#### 추상화
- 사용자는 세부적인 내용을 알 필요가 없다.
- 이러한 세부적인 내용을 숨기는 것이 추상화
- 정의 : 

#### DB 생명주기
- 기획 - 분석 - 설계 - 구현 - 테스트 - 수정 -

#### 모델링의 3가지 관점

#### ER Diagram
- Peter Cheng's Notation
#### IE 표기법 

#### Barker's Notation

#### 데이터의 중복으로 인한 이상 현상
- 정규화
    - 테이블을 분리하는 것
    - 장점 : 삽입, 삭제, 갱신 빠름.
    - 단점 : 조회 느림
        - 조회할 때마다 `JOIN`작업을 해주어야 해서, 조회가 느리다.
        - 그래서 우린 정규화를 일단 진행하고, 성능을 보며, 역정규화를 해나간다.

- 역정규화
    - 테이블을 결합하는 것
    - 장점 : 조회 빠름
    - 단점 : 삽입, 삭제, 갱신 느림

- 변경 이상
    - 고칠려고 하는 것이 1개인데, `여러 번 수정`해야 하는 경우
        - 이는 `데이터 불일치를 야기`할 수 있다.

- 삽입 이상
    - 삽입할 수 없는 현상 , 삽입 이상
    - PK가 NULL이 되어 값을 INSERT할 수 없음

- 삭제 이상
    - 지우고싶은 정보가 있는데 정보를 삭제할 수 없음.

#### 함수적 종속
- 종류
    1. 완전 함수적
        - 기본키 전체를 가지고 종속
    2. 부분 함수적
        - 기본 키가 2개 이상으로 구성되었을 떄, 부분 집합에 종속되었을 때
    3. 이행적 종속 
        - X->Y, Y->Z 일때, X->Z인 경우
#### 정규화
- 1차 정규화 ~ 5차 정규화
- 단점
    1. 빈번한 Join 연산의 증가
    2. 부자연스러운 DB Semantic 초래
        - 테이블만 보고 의미 파악이 어려움
    3. 조회/검색 위주에는 부적합하다.
- 업계 동향
    1. 온라인 처리 : 소규모 정규화
    2. 단순 조회용 데이터 : 비정규화
    3. 배치처리 (ex,은행) : 비정규화

#### 반정규화
- 테이블 추가
    - 중복 테이블 추가
        - 
    - 통계 테이블 추가
        - SUM,AVG 등 자주 사용되는 연산 결과를 미리 수행하여 계산해둬서, 조회시 성능을 올려줌
    - 이력 테이블 추가
        - 
    - 부분 테이블 추가
        - EX, 로그인이라면, 사용자 정보에서, id-pw만 따로 빼둔 부분 테이블을 추가하여, 로그인을 빨리 처리할 수 있음
- 테이블 분활
    - 수직
        - 부분 테이블
    - 수평
        - EX, 자주 오는 유저, 자주 오지 않는 유저

### 분산 데이터 베이스
#### 분산 데이터 베이스의 투명성
#### 분산 데이터베이스 설계 방식
#### 데이터 웨어하우스
