# 12월 26일

## Grouping

### GROUP BY
- 실행 순서
    1. FROM
    2. WHERE
    3. `GROUP BY`
    4. HAVING
    5. SELECT
    6. ORDER BY
    7. OFFSET
    8. LIMIT
    - 실행 순서상 GROUP BY가 WHERE 다음이므로, WHERE에서는 `집계함수`를 사용할 수 없다.
- 예시, tStaff 테이블에서 각 depart 별로 salary의 평균을 조회
    ```sql
    SELECT depart, AVG(salary)
    FROM tStaff 
    GROUP BY depart;
    ```
    - 만약 여기서 GROUP BY를 하지 않으면 Oracle(표준SQL)에서는 오류가 난다.
        - GROUP BY를 하지 않고, AVG를 사용하면 모든 tuple에 대한 평균이 나온다. 이때, depart(평균을 대표하는 부서이름)을 무엇으로 보여주어야 하는지 모르기 때문에 오류 발생함.
        - MySQL, MariaDB에서는 오류가 나지 않지만, 이는 에러 사항이므로 조심하기

- 두 개 이상의 Attribute 또는 연산식으로 그룹화
    - 예시 1, tStaff테이블에서 depart와 gender로 그룹화해서 데이터의 개수를 조회
        - 만약, salary가 NULL인 값을 제외하고 보고 싶다면
            ```sql
            SELECT depart,gender,COUNT(salary)
            FROM tStaff
            GROUP BY depart, gender;
            ```
        - 만약 NULL을 포함한 전체 행의 개수를 보고 싶다면
            ```sql
            SELECT depart,gender,COUNT(*)
            FROM tStaff
            GROUP BY depart, gender;
            ```
- GROUP BY 절이 작성되면, SELECT 절에는 `GROUP BY 절에서 사용된 Column 이름`이나 `연산식` 그리고 `집계 함수`만 나와야 한다.
    - Oracle에서는 이 규칙을 어기면 Error 발생
        ```sql
        -- 이렇게 하면 안된다는 예시
        -- tStaff 테이블에서 depart로 그룹화하고 name을 보여줌 
        SELECT depart, name
        FROM tStaff
        GROUP BY depart;
        ```
        - name은 3개에 해당하지 않으므로 안된다. 정확히는 name은 묶어서 1개로 보여줄 수 없으니까 에러(연산할 수 없으니까)
    - MariaDB, MySQL은 규칙을 어기면 첫 번쨰 데이터를 반환한다.
    - ORM으로 구현할 때, DB를 바꾸게 될 수 있음. 이때, 우리가 이런 실수를 하면, 에러가 발생하면서 위험해짐. 따라서, 유의해서 잘 만들자

- GROUP BY 절을 사용했는데, GROUP화한 `Column`이나 `연산식을 조회하지 않는 것`도 바람직하지 않다.
    - 내가 무엇을 GROUP화 했는지 나타내어야 하므로 GROUP화한 Column을 나타내줘야 한다.
        - 잘못된 예시
            ```sql
            SELECT sum(salary)
            FROM tStaff
            GROUP BY depart;
            ```
    - 내가 GROUP화해서 무엇을 진행할 목적이 있으므로, 그것을 보이기 위해 `연산식`을 같이 조회해줘야 한다.
        - 잘못된 예시
            ```sql
            SELECT depart
            FROM tStaff
            GROUP BY depart;
            ```

- `GROUP BY`를 사용하면, `DISTINCT`와 유사한 결과를 만들어낼 수 있다.
    - 예시, tStaff 테이블에서 `depart의 종류를 조회`
        ```sql
        -- DISTINCT 사용
        SELECT DISTINCT depart
        FROM tStaff;
        ```
        ```sql
        -- GROUP BY 사용
        SELECT depart
        FROM tStaff;
        GROUP BY depart;
        ```
### HAVING 절
- GROUP BY 이후에 적용되는 조건절
- 기본 형식
    ```sql
    SELECT 열 이름 / 연산식 나열
    FROM 테이블 이름 / SELECT 구문  
    [WHERE 조건절]
    [GROUP BY 그룹화할 열 이름이나 연산식을 나열]
    `[HAVING 그룹화 이후의 조건]`
    [ORDER BY 정렬한 열 이름이나 연산식을 나열]
    ```

- 예시 1, buytbl 테이블에서 총 구매액(price*amount)이 1000보다 큰 userID와 총 구매액을 조회
    ```sql
    SELECT userID, SUM(price*amount)
    FROM buytbl
    GROUP BY userID
    HAVING SUM(price*amount) > 1000
    ```
    - 이 경우엔 WHERE를 사용할 수 없다. 
        - 만약 WHERE를 쓴다면 아래와 같은 형태
            ```sql
            SELECT userID, SUM(price*amount)
            FROM buytbl
            WHERE SUM(price*amount) >1000 -- -> GROUP BY 이전에 실행되는 절이므로, 집계함수(SUM)을 사용할 수 없다.
            GROUP BY userID
            ```
- 예시 2, tStaff 테이블에서 depart별로 그룹화한 후, salary의 평균이 340 이상인 데이터의 depart와 평균값을 오름차순으로 정렬하라.
    ```sql
    SELECT depart, AVG(salary) as "평균 임금"
    FROM tStaff
    GROUP BY depart
    HAVING AVG(salary) >= 340
    ORDER BY "평균 임금" ASC;
    ```
- 예시 3, tStaff 테이블에서 depart가 인사과와 영업부인 데이터의 depart와 salary의 최대값을 조회
    - `HAVING 없이`
        ```sql
        SELECT depart, MAX(salary)
        FROM tStaff
        WHERE depart IN ('인사과','영업부') 
        GROUP BY depart
        ```
    - `HAVING 있이`
        ```sql
        SELECT depart, MAX(salary)
        FROM tStaff
        GROUP BY depart
        HAVING depart IN ('인사과','영업부')
        ```
    - HAVING 대신 WHERE를 사용할 수 있으면 `WHERE`를 사용하는 것이 `더 효율적`이다.
        - 실행 순서상 WHERE가 더 앞에 있다.
            - 따라서 WHERE에서 필터링을 하면, 남은 적은 데이터로 GROUP BY를 하는 것이므로 `효율적이다`
    
## WINDOW 함수
- 행과 행 사이의 관계를 정의하기 위해 제공되는 함수
    - `OVER 절`이 들어간 함수다.

### WINDOW 사용하는 2가지 함수
1. 순위 함수
- RANK, NTILE, DENSE_RANK, ROW_NUMBER, PERCENT_RANK
    - `RANK`, `DENSE_RANK` : 동점이 나왔을 때 어떻게 처리할지에 따라 차이
        - `RANK` : 동점이 발생하면 그 다음 숫자는 + 동점자 수 더해서 진행
            - ex 2명이 공동 1등이면, 2등 없고, 다음 3등
        - `DENSE_RANK` : 동점이 발생해도, 그 다음 숫자는 이어서 감
            - ex 500명이 공동 1등이어도, 다음은 2등

    - `PERCENT_RANK` : 백분률
        - 0~1 중 순위로 몇 %인지 확인할 수 있음

    - `NTILE` : 그룹화에 관한 것, N 등분
        - NTILE(`정수`)를 입력하면, 순위별로 `정수` 등분하여 보여줌

    - `ROW_NUMBER` : 순서 매겨주는 것 
        - ROW_NUMBER는 동점자가 발생해도 그냥 순서를 1등,2등,3등 이렇게 처리함
2. 분석 함수
- CUME_DIST,LEAD,FIRST_VALUE,LAG,LAST_VALUE,PERCENT_RANK(얘는 둘 다 가능)
    - `CUME_DIST` : 누적 백분률
    - `LEAD` / `LAG` : 현재 행 기준으로 (다음 행 / 이전 행)
    - `FIRST_VALUE`/`LAST_VALUE` : 첫 행의 값 / 마지막 행의 값
    - `PERCENT_RANK` : 

### WINDOW 사용 예시
#### 순위함수
1. usertbl 테이블의 나이가 많은 순(birthyear)으로 순위를 매겨서 조회
    ```sql
    SELECT name, birthyear, RANK() OVER(ORDER BY birthyear)
    FROM usertbl;
    ```
2. usertbl 테이블을 addr 별로 그룹화해서 그룹 내 나이가 많은 순으로 조회
    ```sql
    SELECT name,birthyear, RANK() OVER(PARTITION BY addr ORDER BY birthyear)
    FROM usertbl;
    ```
3. usertbl 테이블의 나이를 백분률로 표기
    ```sql
    SELECT name, birthyear, PERCENT_RANK() OVER(ORDER BY birthyear)
    FROM usertbl;
    ```
4. tStaff 테이블에서 여자의 비율을 표기
    ```sql
    SELECT distinct gender,PERCENT_RANK() OVER(ORDER BY gender)
    FROM tStaff;
    ```
5. tStaff 테이블의 성별 그룹에서 입사일 순위를 입사 빠른 순->느린순으로 정렬
    ```sql
    SELECT name,gender,joindate,RANK() OVER(PARTITION BY gender ORDER BY joindate ASC)
    FROM tStaff; 
    ```
6. tStaff 테이블의 입사일을 기준으로 7개의 그룹으로 분할
    ```sql
    SELECT name, joindate, NTILE(7) OVER(ORDER BY joindate)
    FROM tStaff;
    ```
--- 예시 추가하기 ---
#### 분석 함수
1. usertbl에서 다음 행과의 birthyear 차이
    ```sql
    SELECT name, birthyear, birthyear-LEAD(birthyear,1) OVER(ORDER BY birthyear)
    FROM usertbl;
    ```
2. usertbl에서 % 누적합 나타내기 (다시 한 번 알아보기)
    ```sql
    SELECT name, birthyear, CUME_DIST() OVER(ORDER BY birthyear DESC)
    FROM usertbl;
    ```
3. tStaff 테이블의 연봉을 이전사람과 비교하여 얼마나 차이나는지 확인하고, 최저 급여, 최고 급여, 누적 분포, 백분위 순위를 나타내기
    ```sql
    SELECT name, 
    ```
--- 예시 추가하기 ---

### WITH ROLLUP 기능
- `GROUP BY`와 같이 사용해서 `그룹 합계`, `총 합계`를 만들어주는 기능
- 예시, order_d 테이블에서 goodscd별로 그룹화해서 qty의 합계를 조회
    ```sql
    SELECT goodscd,SUM(qty)
    FROM order_d
    GROUP BY goodscd;
    ```
    - 만약 여기서 총합계를 알고싶다면
        ```sql
        SELECT goodscd, SUM(qty)
        FROM order_d
        GROUP BY goodscd WITH ROLLUP;
        ```
### PIVOT 기능
- 한 열에 포함된 `여러 값을 출력`하고, 이를 `여러 열로 변환`해서 `테이블 반환식`을 만들어 내는 것
- 예시1, uName과 season으로 `피봇 테이블` 생성
    ```sql
    SELECT uName,SUM(IF(season="봄",amount,0)) AS "봄",SUM(IF(season="여름",amount,0)) AS "여름",SUM(IF(season="가을",amount,0)) AS "가을",SUM(IF(season="겨울",amount,0)) AS "겨울",SUM(amount) AS "총 합계",
    FROM pivot
    GROUP BY uName;
    ```
## DDL
### 테이블 생성
#### 기본 형식
```sql
CREATE [TEMPORARAY] TABLE [IF NOT EXIST] 테이블명(
    컬럼명1 타입,[CONSTARAINT 제약 조건 이름] 컬럼 제약 조건,
    컬럼명2 타입,
    컬럼명3 타입,
    ...,
    [CONSTARAINT 제약 조건 이름] 테이블 제약 조건)ENGINE = 엔진명;
```
#### 데이터 타입
- `숫자` : BIT, INT, FLOAT, DOUBLE, DECIMAL(전체자리수, 소수 자리수)
- `문자` 
    - CHAR(바이트 수 - 255까지) 
        - ex, `CHAR(10)`
    - VARCHAR(바이트 수 - 65535까지)
        - ex, `VARCHAR(10)`
    - TEXT : 65535자까지
    - LONGTEXT : 43억자까지
    - BLOB(Binary Large OBject) : 65535자까지
        - 텍스트가 아닌 2진 데이터를 저장한다.
        - 이미지, 동영상, 사운드 등 
    - LONGBLOB : 43억자까지
        - 최근에는 `LONGBLOB을 이용해서 대용량 이미지, 동영상, 사운드를 저장하는 것`보단 `S3`같은 `저장소를 이용하여 저장`하고 `S3의 url을 VARCHAR로 저장`하는 방식을 주로 사용한다.
- `날짜`
    - DATE
    - DATETIME
    - TIMESTAMP
- `BOOL`
- `JSON`
- `GEOMETRY`
- `ENGINE`
    - MyISAM 
        - 구조
            > 테이블 하나 생성시 하드디스크에 아래의 3개 파일이 생성된다.
            > - `.frm` : 테이블의 `구조`가 저장된 파일
            > - `.MYD` : 실제 `데이터(행)`이 저장된 파일
            > - `.MYI` : 해당 테이블의 `인덱스` 정보가 저장된 파일
        - 특징
            1. 데이터와 인덱스가 분리되어 있다.
                - 인덱스를 찾고 실제 데이터를 가져올 때, 파일 2개를 이동해야 하지만, 구조가 단순하여 파일 단위 복사(백업)하기가 편하다.
        - `구조가 단순`하여 `전체 텍스트 검색`이나 `단순 읽기` 작업이 많은 경우 `속도가 매우 빠르다.`
        - Transaction 미지원
    - InnoDB : 
- `AUTO_INCREMENT`
    
- `CHARSET`


## 참고

1. Oracle, MySQL/MariaDB/MongoDB
- Oracle : User > Database
    - User가 더 크다.
    - 따라서, 로그인을 하면 Database를 사용할 준비가 끝난다.
- MySQL/MariaDB/MongoDB : Database > User
    - Database가 더 크다.
    - 따라서 User가 달라도, Database이름이 같으면 안 된다.
    - 또한, 로그인을 하더라도 Database 사용(`use Database`)을 알리지 않으면 안된다.
