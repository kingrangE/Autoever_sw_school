# 12월 19일 2번째 수업 총정리
> 어제 수업은 학교 기말고사로 인해 듣지 못했다.

## 1번째 수업 복습

### 파이썬의 구성 요소
- `Literal` : 개발자가 직접 입력한 데이터
- `Variable` : 변수, 데이터를 재사용하기 위해 데이터를 저장한 공간
- `Function(method)` : 함수, 자주 사용하는 코드를 사용하기 위해 묶어놓은 것
- `Class` : 동일한 목적을 위한 `데이터`와 `기능`을 묶어놓은 것
- `Module` : 여러 구성 요소들을 묶어 놓은 것 (하나의 파일)
- `Package` : `관련 있는 모듈의 모임`, 파이썬 라이브러리 배포 및 설치 단위

### 파이썬 코딩
- 하나의 라인에 2개 이상의 실행 문장을 사용할 때 **문장을 구분하기 위해** `;`를 사용함.
- 코드의 block 구조를 정의하기 위해 **들여쓰기**를 사용한다.
    - 들여쓰기가 맞지 않으면 Error 발생

### 속성과 도움말 확인
- 가장 정확한 것은 누군가의 말이 아닌 `Document` : Docs는 제작자가 작성한 것이기 때문
    - 따라서 아래처럼 확인하고 사용하는 것이 가장 정확하다. 
- Python Library는 영어로 써야한다. (한국어 라이브러리가 없는 이유)
    - 따라서 영어를 열심히 하자.
- 속성(attribute)을 확인하려면, (ex, 처음 사용해보는 자료형 등)
    - `dir(object)`로 확인할 수 있다.
        - `dir`은 object의 속성을 리스트로 반환한다.
        - ex
            ```python
            # int 속성 확인
            print(dir(int)) 
            # list에 sort 있는지 확인
            print('sort' in dir(list))
            ```
- 동작이 궁금하면, (메서드 설명이 필요하면)
    - `help`로 확인할 수 있다.
        - `help`는 자체에 print가 포함되어 있으므로 `print`를 찍어줄 필요가 없다.
        - ex
            ```python
            # sort 사용법이 궁금하다면
            help(list.sort)
            ```

## 금일 수업 복습

### 비교 연산자
- `숫자`와 `데이터`에서만 가능함.

#### 기호 비교 : 기호를 사용하여 비교하는 방식
- `>` : 앞에게 초과 
- `<` : 뒤에게 초과
- `>=` : 앞에게 이상
- `<=` : 뒤에게 이상
- `==` : 같다.
- `!=` : 다르다.

#### 메서드 비교 : object의 메서드를 사용하여 비교하는 방식
- `__gt__` : greater than
- `__lt__`  : less than
- `__ge__` : greater equal
- `__le_` : less equal
- `__eq_`  : 같다.
- `__ne__` : 다르다.

#### 비교 작업 
- `==`를 수행할 때, 그냥 무조건 하나씩 비교하는 것이 아니다. 아래처럼 로직이 효율화 되어있다.
    - 참고) id와 길이는 `list object의 header`에 적혀있다. 따라서 단순 숫자 비교다.
- 로직
    1. `id 확인` : id가 같다면 당연히 같은 값이므로 `True` 반환
    2. `길이 확인` : 만약, 리스트를 비교한다면, 길이가 존재한다. Heap에 저장된 리스트 객체는 `자신의 길이`를 알고 있다. 따라서 빠르게 비교 가능
        - 여기서 다르면 `False` 반환
    3. `타입 확인` : type이 다르다면 당연히 다른 값이므로 `False` 반환
    4. `요소별 비교` : 2~3이 모두 통과라면, 이제 하나씩 요소를 검사한다.

---
### 산술 비트 연산자 (매우 중요) : 그래픽 프로그램의 색상 관련 기능, 프로그램의 단축키, 운영체제의 삭제/복사 구현에 사용
#### 정의 
> `정수 데이터`를 `2진수`로 변환해서 `비트 단위` 연산 수행 후, 결과를 `10진 정수로 Return`하는 연산자 
>- `시스템 프로그래밍/데이터 분석`에서 자주 사용한다.

#### 종류
1. `&` : `AND` 연산
    - 사용 예시 : 프로그램 삭제에서 이용
        - 프로그램이 없다 -> 모든 비트 0
        - 프로그램 비트와 0비트와 AND 연산하면 삭제 된다.
2. `|` : `OR` 연산
    - 사용 예시 : 프로그램 이동 및 복사
        - 프로그램 비트와 0비트를 OR연산하면 프로그램 비트 그대로 나오는 것을 이용
3. `^` : `XOR` 연산
    - 사용 예시 : 암호화 복호화
        - 프로그램 비트와 키 비트를 XOR연산 2번 취하면 그대로 프로그램 비트가 나온다.
        -  이 2번이 암호화와 복호화다.
4. `~` : `NOT` 연산
    - 사용 예시 : 색상 반전
        - 색상에 NOT을 취하면, 모든 색 비트가 뒤집어지므로 반대 색이 나온다.
5. `<<` : `왼쪽 시프트` 연산
6. `>>` : `오른쪽 시프트` 연산
    - 시프트 연산은 *2와 /2의 효과가 있다. 그러나 곱연산보다 비트 연산이 훨씬 빠르므로 효율적인 곱셈 나눗셈에 사용된다.

#### 진법 변환
- 우리가 아는 그거다. 10진 -> 2진은 2로 0이 될때까지 나누어서 나머지 이어 붙이기
- -1의 의미
    - -1은 1의 보수다.
        - 1 : 0000 0001 
        - -1 : 1의 1의 보수 + 1 = 1111 1110 + 1 = 1111 1111
        - 모든 비트가 1이라는 것 -> 해당 비트에서 나올 수 있는 가장 큰 수를 의미
            - 따라서 아래의 경우 응용이 가능하다.
                1. 무한 재생을 나타낼 때, -1로 표시를 한다.
                2. Container에서 모든 인덱스를 다 검사해봄 -> 못 찾음 -> 끝까지 순회했다는 의미에서 1111 1111 (-1)로 표시한다.
                    - 예시
                        ```python
                        print("Hello".find('f')) # -1
                        print("Hello".find('e')) # 1
                        ```
- 키보드 단축키 -> 2진수를 활용함.
    - 동시에 누를 수 있는 요소 (Command, Ctrl, Alt, Shift, 마우스 클릭 등)은 각 비트의 숫자에 대응시킨다.
        - ex, 마우스 왼클릭 = 1 (01), 마우스 우클릭 = 2 (10), Shift = 4 (100)...
        - 따라서 눌렸는지 안 눌렸는지를 비트로 알 수 있고, 동시에 눌러도 다른 한 가지에 영향이 가지 않는다.
    - 동시에 누를 수 없는 요소는 연속적으로 숫자가 할당되어 있다. 
        - ex, a=63,b=64,c=65... 
        - 이런 것들은 비트가 겹치므로 동시에 누르면 안된다.
---

### 논리 연산자

#### 종류
- `and` : 모두 참 -> `참`
- `or` : 하나 이상 참 -> `참`
- `not` : 부정(반대로 바꿈)
- `all` : Iterable 사용하는 `and`
    - Iterable의 모든 요소가 참이면 참
- `any` : 컨테이너 자료형에 사용하는 `or`
    - Iterable의 모든 요소가 거짓이면 거짓
#### 참고
1. `and`가 `or`보다 우선 순위가 높다.
2. `and`/`or`은 앞에서부터 검사함. 앞에서부터 검사하다가 `하나라도 거짓이면 False`(and)/ `하나라도 참이면 True`(or)를 return한다.
    - 따라서 이 점을 이용하여 최적화를 진행할 수 있다.
    - A or B에서 A가 True일 확률이 30% B가 True일 확률이 70%라면 B or A로 작성해야 두 번 검사하는 작업을 최소화할 수 있다.
3. `bool` 데이터가 아닌 `scala(숫자)` 데이터
    - 0 : `False`
    - 그 외 모든 숫자 : `True`
4. `Container(list)`
    - 데이터 X : `False`
    - 데이터 존재 : `True`

---
### 복합 할당 연산자
- 연산자와 등호 합친거
    - +=,*= 등
- 여기서 등호와 함께 사용하는 것은 최근에 잘 사용하지 않는 추세
    - 예전 : 메모리 제한, 현재 : `메모리 풍부`(이론상 무한(2^64))
    - `데이터 원본을 유지하는 것`이 `중요`해짐 (자꾸 변경하면 작업을 반복해야 할 수 있고, 에러 발생할 확률 높음)
        - ex, 수집 -> 저장 -> 처리인데, 하나의 변수로 계속하면 처리 후 결과가 별로일 때마다 수집부터 다시 해야한다.
        - 따라서 최근엔 `새로운 변수에 저장`하는 것을 선호 (원본 최대한 유지)
---
### 기타 연산자
- 중요
- type(데이터) : `데이터의 자료형`을 `문자열로 반환`
    - 사용 예 : 크롤링해 온 데이터 -> 1인지 '1'인지 알아야 에러없이 처리함. 이때 사용
- id(데이터) : `저장 위치를 구분하기 위한 문자열` 리턴
    - 사용 예 : 2개의 데이터가 저장된 곳이 같은지 확인할 때 사용
        - 의역 : `데이터가 똑같은지`
- id 심화
    - Python에서 `정수,리터럴`은 같은 값이라면, 다른 변수에 선언해도 같은 곳을 가리킨다.
    - Python에서 `리스트`는 같은 값이어도, 다른 변수에 선언하면 다른 곳을 가리킨다.
    - 왜 그럴까?
        - Python의 `정수 인터닝(Interger Interning)` : -5~256의 작은 정수를 Heap에 미리 저장해둠. Int 변수 정의는 변수가 이 곳의 주소를 가리키도록 하는 것
            - Q) 256이 넘는 숫자도 코드 쓰니까 되던데?
            - A) Python Compiler의 `Constant Folding 기능`, 컴파일러는 소스코드를 실행 전, 코드 블록을 한 번 훑는다. 이때, `같은 상수가 두 번` 쓰인다면, `한 개만 만들어서 정수 인터닝처럼 사용`하도록 한다. 이것이 `Constant Folding`이다.
                - 따라서, 소스 코드가 아닌 interpreter에서 실행하면, 다르다고 나온다. (`해봄 진짜 다름`) 
        - List는 왜 안될까? 
            - List는 값이 언제든 바뀔 수 있는 Mutable 객체다.
                - 따라서 다른 변수가 같은 곳을 가리키게 하면 문제가 발생할 가능성이 높음.
            - Q) 그럼 tuple같은 Immutable은?
            - A) `Constant Folding`이 가능한, `소스코드`에서는 같다. 하지만 interpreter에서는 다르다고 나온다. (컴파일러가 최적화하기 때문)
            - Q2) 그럼 tuple은 항상 id가 같나?
            - A2) tuple 안에 list처럼 mutable한 요소가 있다면 또 값이 달라진다.
---
### 자료형(데이터) 형 변환
- 데이터의 형식을 변환하는 것
- `str`형 변환
    - `모든 데이터`는 `str`로 변경 가능
- `int`형 변환
    - 변경 가능한 경우 -> 변경
    - 변경 불가한 경우 -> Error
---
### 제어문 (반복 / 분기)
- `프로그램의 흐름을 변경`하는 것을 `제어문`이라 한다.
    - `제어문`은 `중첩이 가능`하다.

#### 분기
- `if-elif-else` : 조건에 의한 분기
    - 형태
        ```python
        if(조건) :
            조건이 True일 때 수행할 명령
        elif (조건) :
            if 조건이 거짓이고, elif 조건이 True일 떄 수행할 명령
        else :
            if와 elif 조건 모두 거짓일 때 수행할 명령
        ```
    - else를 예외 처리로 사용하는 경우도 존재한다.
        - 예시
            ```python
                score = input("점수 입력(0-100):")
                if score >=80 and score <=100 :
                    print("합격")
                elif score >= 60:
                    print("보류")
                elif score >= 0 :
                    print("불합격")
                else : # 이렇게 처리해서 에러 핸들링이 가능하다.
                    print("값을 0-100 사이로만 입력해주세요.")
                ```
- `match-case`(switch) : 값에 의한 분기
    - python 3.10부터 switch 기능을 갖는 `match-case`가 도입되었다.
    - 형태 
        ```python
        match 데이터 :
            case 값1 :
                데이터 == 값1일 때, 수행할 문장
            case 값2 :
                데이터 == 값2일 때, 수행할 문장
            case _ :
                # default 역할
        ```
    - switch와의 차이점
        - break를 사용하지 않음
    - if와의 차이점
        - if는 순차적 진행 -> sequence의 느낌
        - match-case는 접근 진행 -> key-value의 느낌
        - 따라서 근소하게 `match-case`가 더 빠르다.

#### 반복
- `while` : 반복
    - 형태
        ```python
        while(조건):
            조건이 참인 동안 수행할 명령
        else :
            while문이 break같은거 안 걸리고, 조건에 따라 정상적으로 실행하다 종료된 경우 수행할 명령
        ```

- `for` : 순회 (iterable 데이터를 순차적으로 접근)
    - 형태 
        ```python
        for 임시변수 in 컨테이너 : # 임시변수 안 쓰면 _로 표기
            수행할 내용
        else :
            while-else와 동일함
        ```
    - 특정 자료형이 for문 순회가 가능한지 확인하는 방법
        - dir(자료형)을 했을 때, `__iter__`메서드가 있는지 확인하기

### 함수

#### 정의
> 한 번에 실행되어야 하는 문장들을 하나의 이름으로 묶어서 독립적으로 실행할 수 있도록 하는 것
- `함수의 이름` : `함수의 참조` (reference)
- `함수 이름()` : `함수의 호출(실행)`

#### 함수 장점
> 코드의 일정 부분을 `별도의 논리적 개념`으로 분리할 수 있기 때문에 `가독성`이 좋아짐 (중복 제거, 유지 보수 용이 장점)

#### 함수와 메모리
- 함수를 호출하면 생성되는 메모리의 자료구조 -> `Stack`
    - 함수를 호출하면, `메모리의 Stack영역`에 `함수의 변수들이 생성`된다.
        - 파이썬의 경우, `Stack 영역`에는 `주소를 갖는 변수 이름만 생성`된다. (크기를 매우 적게 차지), 실제 데이터는 `Heap의 반영구 영역에 생성`된다.
    - 함수 1개가 Stack에서 차지할 수 있는 `최대 크기는 1MB`
        - 이러한 이유로 `재귀함수가 재귀를 많이하면 1MB를 넘어가서 에러`가 발생하는 것
        - Q) 만약 이 크기를 넘으면? 
        - A) Error (Stack Overflow)

    - Q) `메인 함수도 함수`인가? 
    - A) 이름이 함순데 당연히 함수지, `메인도 Stack에 생성되는 함수`다.

    - Q) 메인 함수에서 호출하는 `데이터가 500MB면 에러가 나나?`
    - A) `파이썬은 그렇지 않다.` 파이썬에서는 `변수는 주소만 가지기 때문에 Stack에서는 주소 비트의 크기만 차지`하고, `실제 데이터는 Heap영역에 저장`된다. 그러나 `C언어의 배열(동적할당 X)의 경우` 실제로 `배열을 그만큼 할당`하여 `데이터를 넣는 것`이므로 `에러가 발생`한다. (`동적할당하여 사용하는 경우 파이썬과 동일`하기 때문에 에러가 발생하지 않는다.) 
        - 동적 할당하여 사용하는 것을 우리는 **참조 포인터**라고 한다.
    
- 메인 함수의 크기가 1MB를 넘어가는 경우 에러가 발생하기 때문에, 우리는 함수로 분리하여 메인 함수의 크기를 분할해야 한다. (함수 여러 개로 구분하면, 그 함수 각각들이 1MB씩 차지하기 때문)

#### 종류
1. `Built-In Function` -> 파이썬에서 제공하는 `내장 함수`
    - 예외, sum,max 등의 내장 함수들이 있다.
    - 이 내장 함수들은 `파이썬 프로그램 실행 시`->`Stack 영구 영역에 로드`된다.
2. `User Define Function` -> 개발자가 제작하는 Custom 함수

#### 특징
1. `일급 객체`다.
    - `일급 객체` : 하나의 데이터로 취급되는 객체
2. `함수도 하나의 자료형`이다.
3. `runtime`(실행 도중)에 생성이 가능하다.
    - C언어는 runtime에 함수 생성이 안되고, Compile(실행 전)단계에서 함수를 미리 다 생성해둬야 한다.
        - 그래서 우린 C언어 소스코드 상단에 `함수 원형 선언`을 하거나, 함수를 위에 작성해야 한다.(함수가 있음을 알림)
        - 정적 프로그래밍 방식의 장점 (C언어 장점)
            - 속도가 빠르다.
            - 메모리를 많이 소비한다.
        - Server Programming은 `안전하고 빨라야`한다. 따라서 C처럼 미리 준비해두는 방식을 취하는 것이 좋음
        - Client Programming은 동작하는게 우선이므로 `동적 프로그래밍`이 좋음
4. `변수에 대입`할 수 있음
5. `함수의 매개변수로 사용` 가능
6. `함수를 리턴`할 수 있음
- 4~6은 모두 함수가 `하나의 데이터`로 취급되기에 가능하다.

#### 함수 정의 방법
```python
def 함수이름(인수들):
    실행할 명령 나열
    return <값> # 생략 가능
```
- return이 없는 경우,
    1. 생략
    2. None 표시
- 함수 명령 실행 중 return을 만나면, 그대로 Stack 영역의 함수 정보가 사라지고, return value만 남는다.
    - 그렇기 때문에 우리가 함수 안에서 사용한 지역 변수를 재활용할 수 없는 것이다.

#### Argument(인수, 인자)
- `parameter`,`매개변수`라고도 부른다.
- 함수를 호출할 때 넘겨주는 데이터를 의미
    - 함수는 Arguments를 가지고, 명령을 수행하여, `결과를 돌려주거나` `전달받은 Arguments에 변형`을 가한다.
- 매개변수의 종류에 따른 차이
    1. 매개변수가 `Scala`데이터 (call by value)
        - scala 데이터는 `수치형`데이터를 말한다.
    2. 매개변수가 `Vector`데이터 (call by reference)
        - Vector 데이터는 `list`데이터를 말한다.
            - ex)
                ```python
                def call_by_ref(a:list)->None:
                    a.append('0')
                l = [1,2,3]
                call_by_ref(l)
                print(l) # [1,2,3,'0']
                ```
- 함수 호출 시, Argument의 이름과 함께 데이터를 넘기는 것이 가능하다.
    - 이 방식을 사용하면, 순서를 맞추지 않아도 괜찮다.
    - 가독성을 올려주고, 명확하게 표현해준다는 장점이 있다.
    - 예시
        ```python
        def test(a:int,b:int)->None:
            print(a+b)
        test(b=5,a=10)
        # a,b 순서 바꼈는데 ㄱㅊ
        ```
- 기본값
    - 매개변수에 기본값을 지정해줄 수 있다.
    - 기본값을 가진 매개변수는 함수 호출 시, 값을 지정해주지 않아도 실행된다.
    - 기본값을 가진 매개변수 뒤의 모든 매개변수는 모두 기본값을 가져야 한다.
    - 예시
        ```python
        def test(a:int,b:int=5,c:int=10)->int:
            return a+b+c
        print(test(1)) #16
        print(test(1,2)) # 13
        print(test(1,2,3)) # 6
        ```
- unpacking(`*`) 기능
    - 매개변수로 `list`,`tuple`,`set`이 입력될 때, 앞에 `*`을 붙이면
        - 각 자료형이 해체되어 순서대로 들어감
            - 예시
                ```python
                def two_arg(a:int,b:int)->None:
                    print(f"a={a},b={b}")
                two_arg(*[1,2]) # a=1,b=2 출력
                ```
    - 매개변수로 `dict`가 입력될 때, 앞에 `**`을 붙이면
        - dict의 키가 매개변수에 매칭되어 dict의 value가 각각 들어가게 됨.
            - 예시
                ```python
                def sum(num1:int,num2:int)->None:
                    print(num1+num2)
                sum(**{'num1':5,'num2':4}) # 출력 9
                ```
- 가변 매개변수
    - 매개변수의 개수에 상관없이 `대입`받도록 하는 문법
    - `*`을 이용해서 정의하면, `tuple`로 만들어 사용하는 것, `**`을 이용해서 정의하면, `dict`로 만들어 사용하는 것
        - ex, sum함수
            ```python
            def sum(*args)->int:
               result = 0
               for i in args:
                    result += i
                return result 
            ```
        - ex, 옵션 설정
            ```python
            def set_option(user_id:int, **options)->dict:
                profile = {'id':user_id}
                for k,v in options.item():
                    profile[k]=v
                return profile
            ```
#### typehint
- 함수의 `매개변수(파라미터)`와 `리턴값`의 자료형을 나타내 줄 수 있다.
- 장점
    1. 가독성 향상
    2. 명확성 향상
    3. 알 수 없는 에러 방지
- 예시
    ```python
    def typehint_ex(a:int, b:str)->list:
        result = []
        result.extend([a,b])
    print(typehint_ex(1,'2'))
    ```


#### 순수/비순수 함수
- 순수 함수 조건
    1. 입력하는 데이터가 같으면, 항상 동일한 결과를 Return한다.
- 비순수 함수 조건
    1. 입력한 데이터가 같아도, 결과가 다르게 Return된다.
        - ex, 현재 시간 반환, 셔플하는 함수 등
        - but, 게임 구현은 random이 아니다. 어느정도 보정값이 있다.(처음 하는 애가 오래한 애보다 운이 좋아서 잘 되면 오래한 애 이탈됨)
#### 재귀 함수
- 함수가 자기 자신을 내부에서 다시 호출하는 것
    - ex) 1~9합계
        1. 1~8합계 + 9
        2. 1~8합계 = 1~7합계 + 8
        3. ...
- 단점
    1. 메모리 부담 커짐
    2. 속도 느려짐
        - 함수 하나하나가 stack을 차지하고, 수행할 것이 많아지기 때문
    - 따라서 코테에서는 조심히 풀어야 한다.
        - 최대한 안 쓰는게 좋지만, 안 써서 못 풀겠으면 써야함
- 장점
    - 코드가 단순해진다.

#### lambda : 이름 없는 1줄 짜리 함수
- 작성 방법
    ```python
    lambda <인수 나열> : <리턴할 값>
    lambda a,b : a+b
    ```
- 인수가 없으면 생략이 가능하다.
    - ex) 항상 1 리턴
        ```python
        f = lambda :1
        ```
#### map, filter, reduce    
> `iterable` 데이터를 효율적으로 처리하기 위해 사용하는 함수들

- map
    - 순회하며 연산 (데이터 가공)
    - 정의 : `collection(Container)과 함수를 매개변수`로 받아서 `Collection의 각 요소에 함수를 적용한 결과`를 `Iterator 인스턴스로 리턴`하는 함수
    - 예시, APi 응답에서 필요한 값만 가져오기
        ```python
        def get_name(**kwargs)->list:
            result = list(map(lambda x : x['name'], kwargs))
            return result
        get_name(api_response)
        ```
- filter
    - 특정 조건을 만족하는 데이터 뽑기
        - filter에 포함된 함수를 iterable에 적용하고 결과가 True인 것만 반환하기
    - 즉, 데이터 필터링
    - 예시, 로그 파일에서 에러 추출
        ```python
        def print_error_log(logs:list[str])->None:
            error_logs = filter(lambda x : 'Error' in x,logs)
            for log in error_logs:
                print(log)
        print_error_log(logs)
        ```
- reduce
    - `누적 계산을 수행`하여 `데이터를 하나로 합침` (내장함수가 아님. 내장 모듈(`functools`)에서 import 해야한다.)
    - reduce -> (함수, 데이터, [초기값])을 받음
        - 초기값이 없는 경우 -> 데이터의 첫 번째 요소를 초기값으로 사용
        - 초기값이 있는 경우 -> 초기값을 초기값으로 사용
        - 주의) 함수는 2개의 인자를 받도록 작성해야 한다.
            1. 첫 번째 인자 -> 초기값 (누적 값 계산용)
            2. 두 번쨰 인자 -> 데이터 (순회할 데이터)
    - 예시, 3일간 매출 데이터를 기반으로 메뉴별 판매 금액 계산
        ```python
        from functools import reduce
        def sales_per_menu(result,datas:dict)->dict:
            for k,v in data.items() :
                result[k] = result.get(k,0) + v
            return result
        
        sales = reduce(sales_per_menu,datas,{})
        ```
- map,reduce,filter
    - 실무에서는 이 3가지를 자주 조합하여 사용한다.
        - bigdata에서 자주 사용하는 `하둡`의 경우 가장 강력한 기능 중 하나가 `map-reduce`
    - 예시, 장바구니에서 할인된 총 금액 계산하기 ("전자기기만 할인")
        ```python
        from functools import reduce
        def total_price_in_cart(data:list[dict])->int:
            result = reduce(
                lambda result,price : result+price,
                map(
                    lambda item : item['price'],
                    filter(
                        lambda item : item["category"] == "전자기기",
                        data
                    )
                ),
                0 #reduce 초기값
            )
            return result
        print(total_price_in_cart(cart_data))
        ```
#### `__doc__` 
> 함수의 도움말

- 우리가 help를 찍으면 나오는 설명이 이 __doc__에 적은 내용이다.
    - 이 내용을 기반으로 라이브러리 심사하는 사람들이 심사를 한다.
    - 따라서, 오픈소스 프로젝트를 한다면 꼭 써야한다.

#### 함수 이름만 호출
> `함수 레퍼런스(주소)를 변수에 저장`하는 것
- 이 과정을 통하면 `변수명으로 함수를 호출`할 수 있다.
    - 즉, `함수의 별명을 설정`한다고 생각하면 편하다.
- 장점
    >변경에 유연해진다.
    > - 예를 들어, 함수명이 변경된 경우 
    > - 함수를 직접 사용하는 `모든 곳을 다 수정`해야 한다.
    > - 하지만 변수를 이용한다면, `변수에 등록된 함수명만 변경`하면 된다.
- 일반적으로 함수를 `매개변수`로 전달하고자 하는 경우 사용한다.
---
### Decorator
> Closure를 활용한 기술
> - 기존 함수를 받아 기능을 추가한 새로운 함수를 반환하는 `Design Pattern`

#### Closure
- 자신을 감싸고 있는 외부 함수가 종료된 후에도 `외부 함수의 변수`를 `기억하고 접근할 수 있는 함수`
- 성립 조건
    1. `중첩 함수`여야 한다.
        - Q) 중첩 함수?
        - A) 함수 내부에 함수가 정의된 것
    2. `외부 함수의 변수를 참조`해야 한다.
    3. 외부 함수는 `내부 중첩 함수를 반환`해야 한다.
- 예시
    ```python
    def outer(x):
        def inner(y):
            return x+y
        return inner
    
    a = outer(5) # inner함수를 a에 저장한 것과 같다.
    print(a(10)) 
    """
    위에서 inner함수가 return 5+y하도록 변수에 저장했으므로 
    a에 10을 넣으면 inner함수에 10이 입력되어
    return 5+10이 된다. 
    즉 출력 15
    """
    ```
- 메모리 관계
    - outer 함수는 Stack영역에 저장된다. 
        - outer함수가 종료된 시점에 outer의 Stack Frame은 삭제
        - 하지만, outer함수 내부 변수 `x는 cell에 저장`되어 있고, `inner함수`는 함수 내부의 하나의 객체이므로 `Heap`영역에 존재한다.
        - 따라서 stack에서 삭제되어도 inner와 x는 삭제되지 않았기 때문에 상관없으며, 변수 내부에 outer함수가 반환한 inner pointer가 저장되어 있으므로 inner에 접근해 사용할 수 있는 것이다.

#### Decorator
- 성립 조건
    1. 클로저여야 한다.
    2. 함수를 인자로 받아야 한다.
    3. `내부 함수가 외부 함수가 받은 인자(함수)를 참조`해야 한다.
    4. (실무) `원본 함수가 인자`를 가지고 있을 수 있으므로, `가변 매개변수(*args,**kwargs)를 처리할 수 있도록 작성`해야 한다.

- 목적 : `AoP 실현`을 위함.
    - `AoP` (Aspect of Programming) : 관점 지향 프로그래밍
        - Code는 2가지로 분류된다.
            1. `Business Logic` : 도메인 지식이 요구되는 로직
                - 우리가 실제로 개발하는 Application은 모두 Business Logic이다.
                - Kubernetes로 배포하는 모든 Application이 해당된다고 생각해도 된다.
            2. `Common Concern` : 공통 관심사 (인프라,관리)
                - Kubernetes로 배포한 Application이 잘 동작하는지 확인하기 위해 필요한 도구를 말한다.
                    - 예시 
                        1. Elastic Search (검색 도구)
                        2. Log Stash 
                        3. Fluent d (저장 도구)
                        4. kibnana (시각화 도구)
                        5. grafana & prometheus
        - AoP의 장점
            - `Business Logic`과 `Common Concern`을 분리하여 유지 보수를 쉽게 함.
            - 이것을 가장 잘 실현하는 것이 `Spring`
                - yaml 설정으로 다 할 수 있다.
        - Python에서는 `Common Concern`을 `Decorator로 구현`하여 `Business Logic에 래핑하는 방식`으로 `AoP를 실현`한다.
            - Decorator로 함수를 감싸면, Decorator가 return하는 함수를 호출한다.

- 예시, 가상 주문 처리 로직
    - business logic : 주문 데이터 검증 -> DB 저장
    - common concern : 함수 실행시 걸리는 시간 측정 및 로그 기록
    ```python
    import time
    import functools
    def monitor(func):
        @functools.wraps(func)
        def wrapper(*args,**kwargs):
            start = time.time()
            result = func(*args,**kwargs)
            duration = time.time()-start
            print("함수 :",func.__name__,"실행 시간 :",duration)
            return result
    def error_handle(func):
        @functools.wraps(func)
        def wrapper(*args,**kwargs):
            try :
                return func(*args,**kwargs)
            except Exception as e :
                print(f"{func.__name__} error : {e}")
                raise
        return wrapper
    @error_handle
    @monitor
    def process_order(order_id,items):
        print(f"주문({order_id})에 대한 DB 처리 및 결제 진행")
        return "Order Completed"
    process_order(order_id,items)
    ```
    - 위 코드에서 `@functools.wraps`가 하는 일
        - 데코레이터를 사용하면 wrapper함수의 정보로 함수 메타데이터가 덮어씌워진다.
        - 즉, 메인에서 데코레이터를 사용한 함수의 정보를 출력하는 경우
            - 이때, wrapper함수의 이름과 주석이 나온다는 것이다.
            - ex) func.__name__, func.__doc__ 등
        - `원본 함수의 메타데이터를 지키기 위해`서 `@functools.wraps`로 `wrapper함수를 감싸는 것`이다.
                

---
### 참고

1. 클라우드에서 가장 중요한 것, 가장 잘해야 하는 것 => `LINUX` (Fundamental)
2. 변수와 메모리
    - 프로그램이 사용하는 영역은 크게 2가지로 나뉜다. (Stack, Heap)
        - Stack
            - 임시 영역
                - EX, 함수 -> 변수 생성 등 할당을 하고, 수명이 다하면 없어진다.
                    - 여기서 변수의 주소는 Stack, 실제 데이터는 Heap에 적힌다.
        - Heap
            - 반영구와 영구로 나뉨
                - 반영구 : 읽기/쓰기 기능만 존재, 프로그램 실행 중에 수시로 생성되고 사라지는 영역
                    - 함수가 생성되면 데이터가 쓰여짐, 함수 실행동안 읽기 가능 상태, 함수가 수명이 다해지면 `쓰기 가능 상태`(`자유 구역`, 사용 가능 리스트)가 된다. (`삭제 되는 것이 아님`)
                - 영구 : 프로그램이 시작될 때 생성되어 종료때까지 유지
                    - 파이썬 내장 함수, 예외(builtin), Interning 객체 등
                    - GC(Garbage Collector)의 대상이 되지 않음

3. 프로그래머한테 가독성, 명확성 너무 중요
    - `가독성` : 읽기 편한 코드
        - 옛날엔 문서 작성부터 하는 방식
            - 무엇을 할 지 명확히 하는 것을 중시함.
        - 현재는 개발부터 시작하는 방식
            - 따라서 문서 없이도 의사소통이 용이하게 하려면 `가독성`이 좋아야 한다. (코드만 읽고 이해할 수 있게)
    - `명확성` : 각 기능이 무엇인지, 각 변수의 역할이 무엇인지 `명확하게` 나타내는 것 (가독성과 연관되어 있음)
        - 예시, return에서 ,로 구분하여 여러 변수 리턴
            - 결국 tuple의 형태로 return된다. (`함수는 하나의 데이터만 리턴할 수 있음`)
            - 하지만, tuple인지 모르고 사용하여 오류가 발생할 수 있으므로, ()로 감싸서 tuple임을 `명확하게 하기` 
            - 또는 return값에 `tuple임을 명시하기`
4. 공부할 때, 소스코드 그대로 따라치지 말기.
    - 대안 1) 예시 코드를 내가 생각하는 다른 것으로 변경하여 구현해보기
    - 대안 2) 설명만 보고 내가 코드를 작성해보기

## 숙제
- DB 배우고 실습할 때, 테이블 구조부터 설계해봐야 하므로 DB 배워서 만들고 싶은거 생각해오기 (그거 구현할거임)